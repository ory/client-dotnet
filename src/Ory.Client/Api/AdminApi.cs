/*
 * Ory APIs
 *
 * Documentation for all public and administrative Ory APIs. Administrative APIs can only be accessed with a valid Personal Access Token. Public APIs are mostly used in browsers. 
 *
 * The version of the OpenAPI document: v0.2.0-alpha.29
 * Contact: support@ory.sh
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Ory.Client.Client;
using Ory.Client.Model;

namespace Ory.Client.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAdminApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Accept a Consent Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY Hydra that the subject has authorized the OAuth 2.0 client to access resources on his/her behalf. The consent provider includes additional information, such as session data for access and ID tokens, and if the consent request should be used as basis for future requests.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="clientAcceptConsentRequest"> (optional)</param>
        /// <returns>ClientCompletedRequest</returns>
        ClientCompletedRequest AcceptConsentRequest(string consentChallenge, ClientAcceptConsentRequest clientAcceptConsentRequest = default(ClientAcceptConsentRequest));

        /// <summary>
        /// Accept a Consent Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY Hydra that the subject has authorized the OAuth 2.0 client to access resources on his/her behalf. The consent provider includes additional information, such as session data for access and ID tokens, and if the consent request should be used as basis for future requests.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="clientAcceptConsentRequest"> (optional)</param>
        /// <returns>ApiResponse of ClientCompletedRequest</returns>
        ApiResponse<ClientCompletedRequest> AcceptConsentRequestWithHttpInfo(string consentChallenge, ClientAcceptConsentRequest clientAcceptConsentRequest = default(ClientAcceptConsentRequest));
        /// <summary>
        /// Accept a Login Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY Hydra that the subject has successfully authenticated and includes additional information such as the subject&#39;s ID and if ORY Hydra should remember the subject&#39;s subject agent for future authentication attempts by setting a cookie.  The response contains a redirect URL which the login provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="clientAcceptLoginRequest"> (optional)</param>
        /// <returns>ClientCompletedRequest</returns>
        ClientCompletedRequest AcceptLoginRequest(string loginChallenge, ClientAcceptLoginRequest clientAcceptLoginRequest = default(ClientAcceptLoginRequest));

        /// <summary>
        /// Accept a Login Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY Hydra that the subject has successfully authenticated and includes additional information such as the subject&#39;s ID and if ORY Hydra should remember the subject&#39;s subject agent for future authentication attempts by setting a cookie.  The response contains a redirect URL which the login provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="clientAcceptLoginRequest"> (optional)</param>
        /// <returns>ApiResponse of ClientCompletedRequest</returns>
        ApiResponse<ClientCompletedRequest> AcceptLoginRequestWithHttpInfo(string loginChallenge, ClientAcceptLoginRequest clientAcceptLoginRequest = default(ClientAcceptLoginRequest));
        /// <summary>
        /// Accept a Logout Request
        /// </summary>
        /// <remarks>
        /// When a user or an application requests ORY Hydra to log out a user, this endpoint is used to confirm that logout request. No body is required.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <returns>ClientCompletedRequest</returns>
        ClientCompletedRequest AcceptLogoutRequest(string logoutChallenge);

        /// <summary>
        /// Accept a Logout Request
        /// </summary>
        /// <remarks>
        /// When a user or an application requests ORY Hydra to log out a user, this endpoint is used to confirm that logout request. No body is required.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <returns>ApiResponse of ClientCompletedRequest</returns>
        ApiResponse<ClientCompletedRequest> AcceptLogoutRequestWithHttpInfo(string logoutChallenge);
        /// <summary>
        /// Generate a New JSON Web Key
        /// </summary>
        /// <remarks>
        /// This endpoint is capable of generating JSON Web Key Sets for you. There a different strategies available, such as symmetric cryptographic keys (HS256, HS512) and asymetric cryptographic keys (RS256, ECDSA). If the specified JSON Web Key Set does not exist, it will be created.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="clientJsonWebKeySetGeneratorRequest"> (optional)</param>
        /// <returns>ClientJSONWebKeySet</returns>
        ClientJSONWebKeySet CreateJsonWebKeySet(string set, ClientJsonWebKeySetGeneratorRequest clientJsonWebKeySetGeneratorRequest = default(ClientJsonWebKeySetGeneratorRequest));

        /// <summary>
        /// Generate a New JSON Web Key
        /// </summary>
        /// <remarks>
        /// This endpoint is capable of generating JSON Web Key Sets for you. There a different strategies available, such as symmetric cryptographic keys (HS256, HS512) and asymetric cryptographic keys (RS256, ECDSA). If the specified JSON Web Key Set does not exist, it will be created.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="clientJsonWebKeySetGeneratorRequest"> (optional)</param>
        /// <returns>ApiResponse of ClientJSONWebKeySet</returns>
        ApiResponse<ClientJSONWebKeySet> CreateJsonWebKeySetWithHttpInfo(string set, ClientJsonWebKeySetGeneratorRequest clientJsonWebKeySetGeneratorRequest = default(ClientJsonWebKeySetGeneratorRequest));
        /// <summary>
        /// Create an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Create a new OAuth 2.0 client If you pass &#x60;client_secret&#x60; the secret will be used, otherwise a random secret will be generated. The secret will be returned in the response and you will not be able to retrieve it later on. Write the secret down and keep it somwhere safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientOAuth2Client"></param>
        /// <returns>ClientOAuth2Client</returns>
        ClientOAuth2Client CreateOAuth2Client(ClientOAuth2Client clientOAuth2Client);

        /// <summary>
        /// Create an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Create a new OAuth 2.0 client If you pass &#x60;client_secret&#x60; the secret will be used, otherwise a random secret will be generated. The secret will be returned in the response and you will not be able to retrieve it later on. Write the secret down and keep it somwhere safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientOAuth2Client"></param>
        /// <returns>ApiResponse of ClientOAuth2Client</returns>
        ApiResponse<ClientOAuth2Client> CreateOAuth2ClientWithHttpInfo(ClientOAuth2Client clientOAuth2Client);
        /// <summary>
        /// Delete a JSON Web Key
        /// </summary>
        /// <remarks>
        /// Use this endpoint to delete a single JSON Web Key.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <returns></returns>
        void DeleteJsonWebKey(string kid, string set);

        /// <summary>
        /// Delete a JSON Web Key
        /// </summary>
        /// <remarks>
        /// Use this endpoint to delete a single JSON Web Key.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteJsonWebKeyWithHttpInfo(string kid, string set);
        /// <summary>
        /// Delete a JSON Web Key Set
        /// </summary>
        /// <remarks>
        /// Use this endpoint to delete a complete JSON Web Key Set and all the keys in that set.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <returns></returns>
        void DeleteJsonWebKeySet(string set);

        /// <summary>
        /// Delete a JSON Web Key Set
        /// </summary>
        /// <remarks>
        /// Use this endpoint to delete a complete JSON Web Key Set and all the keys in that set.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteJsonWebKeySetWithHttpInfo(string set);
        /// <summary>
        /// Deletes an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Delete an existing OAuth 2.0 Client by its ID.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  Make sure that this endpoint is well protected and only callable by first-party components.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <returns></returns>
        void DeleteOAuth2Client(string id);

        /// <summary>
        /// Deletes an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Delete an existing OAuth 2.0 Client by its ID.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  Make sure that this endpoint is well protected and only callable by first-party components.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteOAuth2ClientWithHttpInfo(string id);
        /// <summary>
        /// Delete OAuth2 Access Tokens from a Client
        /// </summary>
        /// <remarks>
        /// This endpoint deletes OAuth2 access tokens issued for a client from the database
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId"></param>
        /// <returns></returns>
        void DeleteOAuth2Token(string clientId);

        /// <summary>
        /// Delete OAuth2 Access Tokens from a Client
        /// </summary>
        /// <remarks>
        /// This endpoint deletes OAuth2 access tokens issued for a client from the database
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteOAuth2TokenWithHttpInfo(string clientId);
        /// <summary>
        /// Delete a Trusted OAuth2 JWT Bearer Grant Type Issuer
        /// </summary>
        /// <remarks>
        /// Use this endpoint to delete trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you created the trust relationship.  Once deleted, the associated issuer will no longer be able to perform the JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grant.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the desired grant</param>
        /// <returns></returns>
        void DeleteTrustedJwtGrantIssuer(string id);

        /// <summary>
        /// Delete a Trusted OAuth2 JWT Bearer Grant Type Issuer
        /// </summary>
        /// <remarks>
        /// Use this endpoint to delete trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you created the trust relationship.  Once deleted, the associated issuer will no longer be able to perform the JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grant.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the desired grant</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteTrustedJwtGrantIssuerWithHttpInfo(string id);
        /// <summary>
        /// Flush Expired OAuth2 Access Tokens
        /// </summary>
        /// <remarks>
        /// This endpoint flushes expired OAuth2 access tokens from the database. You can set a time after which no tokens will be not be touched, in case you want to keep recent tokens for auditing. Refresh tokens can not be flushed as they are deleted automatically when performing the refresh flow.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientFlushInactiveOAuth2TokensRequest"> (optional)</param>
        /// <returns></returns>
        void FlushInactiveOAuth2Tokens(ClientFlushInactiveOAuth2TokensRequest clientFlushInactiveOAuth2TokensRequest = default(ClientFlushInactiveOAuth2TokensRequest));

        /// <summary>
        /// Flush Expired OAuth2 Access Tokens
        /// </summary>
        /// <remarks>
        /// This endpoint flushes expired OAuth2 access tokens from the database. You can set a time after which no tokens will be not be touched, in case you want to keep recent tokens for auditing. Refresh tokens can not be flushed as they are deleted automatically when performing the refresh flow.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientFlushInactiveOAuth2TokensRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> FlushInactiveOAuth2TokensWithHttpInfo(ClientFlushInactiveOAuth2TokensRequest clientFlushInactiveOAuth2TokensRequest = default(ClientFlushInactiveOAuth2TokensRequest));
        /// <summary>
        /// Get Consent Request Information
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <returns>ClientConsentRequest</returns>
        ClientConsentRequest GetConsentRequest(string consentChallenge);

        /// <summary>
        /// Get Consent Request Information
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <returns>ApiResponse of ClientConsentRequest</returns>
        ApiResponse<ClientConsentRequest> GetConsentRequestWithHttpInfo(string consentChallenge);
        /// <summary>
        /// Fetch a JSON Web Key
        /// </summary>
        /// <remarks>
        /// This endpoint returns a singular JSON Web Key, identified by the set and the specific key ID (kid).
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <returns>ClientJSONWebKeySet</returns>
        ClientJSONWebKeySet GetJsonWebKey(string kid, string set);

        /// <summary>
        /// Fetch a JSON Web Key
        /// </summary>
        /// <remarks>
        /// This endpoint returns a singular JSON Web Key, identified by the set and the specific key ID (kid).
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <returns>ApiResponse of ClientJSONWebKeySet</returns>
        ApiResponse<ClientJSONWebKeySet> GetJsonWebKeyWithHttpInfo(string kid, string set);
        /// <summary>
        /// Retrieve a JSON Web Key Set
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to retrieve JWK Sets stored in ORY Hydra.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <returns>ClientJSONWebKeySet</returns>
        ClientJSONWebKeySet GetJsonWebKeySet(string set);

        /// <summary>
        /// Retrieve a JSON Web Key Set
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to retrieve JWK Sets stored in ORY Hydra.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <returns>ApiResponse of ClientJSONWebKeySet</returns>
        ApiResponse<ClientJSONWebKeySet> GetJsonWebKeySetWithHttpInfo(string set);
        /// <summary>
        /// Get a Login Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <returns>ClientLoginRequest</returns>
        ClientLoginRequest GetLoginRequest(string loginChallenge);

        /// <summary>
        /// Get a Login Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <returns>ApiResponse of ClientLoginRequest</returns>
        ApiResponse<ClientLoginRequest> GetLoginRequestWithHttpInfo(string loginChallenge);
        /// <summary>
        /// Get a Logout Request
        /// </summary>
        /// <remarks>
        /// Use this endpoint to fetch a logout request.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <returns>ClientLogoutRequest</returns>
        ClientLogoutRequest GetLogoutRequest(string logoutChallenge);

        /// <summary>
        /// Get a Logout Request
        /// </summary>
        /// <remarks>
        /// Use this endpoint to fetch a logout request.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <returns>ApiResponse of ClientLogoutRequest</returns>
        ApiResponse<ClientLogoutRequest> GetLogoutRequestWithHttpInfo(string logoutChallenge);
        /// <summary>
        /// Get an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Get an OAuth 2.0 client by its ID. This endpoint never returns the client secret.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <returns>ClientOAuth2Client</returns>
        ClientOAuth2Client GetOAuth2Client(string id);

        /// <summary>
        /// Get an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Get an OAuth 2.0 client by its ID. This endpoint never returns the client secret.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <returns>ApiResponse of ClientOAuth2Client</returns>
        ApiResponse<ClientOAuth2Client> GetOAuth2ClientWithHttpInfo(string id);
        /// <summary>
        /// Get a Trusted OAuth2 JWT Bearer Grant Type Issuer
        /// </summary>
        /// <remarks>
        /// Use this endpoint to get a trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you created the trust relationship.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the desired grant</param>
        /// <returns>ClientTrustedJwtGrantIssuer</returns>
        ClientTrustedJwtGrantIssuer GetTrustedJwtGrantIssuer(string id);

        /// <summary>
        /// Get a Trusted OAuth2 JWT Bearer Grant Type Issuer
        /// </summary>
        /// <remarks>
        /// Use this endpoint to get a trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you created the trust relationship.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the desired grant</param>
        /// <returns>ApiResponse of ClientTrustedJwtGrantIssuer</returns>
        ApiResponse<ClientTrustedJwtGrantIssuer> GetTrustedJwtGrantIssuerWithHttpInfo(string id);
        /// <summary>
        /// Introspect OAuth2 Tokens
        /// </summary>
        /// <remarks>
        /// The introspection endpoint allows to check if a token (both refresh and access) is active or not. An active token is neither expired nor revoked. If a token is active, additional information on the token will be included. You can set additional data for a token by setting &#x60;accessTokenExtra&#x60; during the consent flow.  For more information [read this blog post](https://www.oauth.com/oauth2-servers/token-introspection-endpoint/).
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The string value of the token. For access tokens, this is the \\\&quot;access_token\\\&quot; value returned from the token endpoint defined in OAuth 2.0. For refresh tokens, this is the \\\&quot;refresh_token\\\&quot; value returned.</param>
        /// <param name="scope">An optional, space separated list of required scopes. If the access token was not granted one of the scopes, the result of active will be false. (optional)</param>
        /// <returns>ClientOAuth2TokenIntrospection</returns>
        ClientOAuth2TokenIntrospection IntrospectOAuth2Token(string token, string scope = default(string));

        /// <summary>
        /// Introspect OAuth2 Tokens
        /// </summary>
        /// <remarks>
        /// The introspection endpoint allows to check if a token (both refresh and access) is active or not. An active token is neither expired nor revoked. If a token is active, additional information on the token will be included. You can set additional data for a token by setting &#x60;accessTokenExtra&#x60; during the consent flow.  For more information [read this blog post](https://www.oauth.com/oauth2-servers/token-introspection-endpoint/).
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The string value of the token. For access tokens, this is the \\\&quot;access_token\\\&quot; value returned from the token endpoint defined in OAuth 2.0. For refresh tokens, this is the \\\&quot;refresh_token\\\&quot; value returned.</param>
        /// <param name="scope">An optional, space separated list of required scopes. If the access token was not granted one of the scopes, the result of active will be false. (optional)</param>
        /// <returns>ApiResponse of ClientOAuth2TokenIntrospection</returns>
        ApiResponse<ClientOAuth2TokenIntrospection> IntrospectOAuth2TokenWithHttpInfo(string token, string scope = default(string));
        /// <summary>
        /// List OAuth 2.0 Clients
        /// </summary>
        /// <remarks>
        /// This endpoint lists all clients in the database, and never returns client secrets. As a default it lists the first 100 clients. The &#x60;limit&#x60; parameter can be used to retrieve more clients, but it has an upper bound at 500 objects. Pagination should be used to retrieve more than 500 objects.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  The \&quot;Link\&quot; header is also included in successful responses, which contains one or more links for pagination, formatted like so: &#39;&lt;https://hydra-url/admin/clients?limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;; rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;, &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will be separated by a comma.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">The maximum amount of clients to returned, upper bound is 500 clients. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="clientName">The name of the clients to filter by. (optional)</param>
        /// <param name="owner">The owner of the clients to filter by. (optional)</param>
        /// <returns>List&lt;ClientOAuth2Client&gt;</returns>
        List<ClientOAuth2Client> ListOAuth2Clients(long? limit = default(long?), long? offset = default(long?), string clientName = default(string), string owner = default(string));

        /// <summary>
        /// List OAuth 2.0 Clients
        /// </summary>
        /// <remarks>
        /// This endpoint lists all clients in the database, and never returns client secrets. As a default it lists the first 100 clients. The &#x60;limit&#x60; parameter can be used to retrieve more clients, but it has an upper bound at 500 objects. Pagination should be used to retrieve more than 500 objects.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  The \&quot;Link\&quot; header is also included in successful responses, which contains one or more links for pagination, formatted like so: &#39;&lt;https://hydra-url/admin/clients?limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;; rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;, &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will be separated by a comma.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">The maximum amount of clients to returned, upper bound is 500 clients. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="clientName">The name of the clients to filter by. (optional)</param>
        /// <param name="owner">The owner of the clients to filter by. (optional)</param>
        /// <returns>ApiResponse of List&lt;ClientOAuth2Client&gt;</returns>
        ApiResponse<List<ClientOAuth2Client>> ListOAuth2ClientsWithHttpInfo(long? limit = default(long?), long? offset = default(long?), string clientName = default(string), string owner = default(string));
        /// <summary>
        /// Lists All Consent Sessions of a Subject
        /// </summary>
        /// <remarks>
        /// This endpoint lists all subject&#39;s granted consent sessions, including client and granted scope. If the subject is unknown or has not granted any consent sessions yet, the endpoint returns an empty JSON array with status code 200 OK.   The \&quot;Link\&quot; header is also included in successful responses, which contains one or more links for pagination, formatted like so: &#39;&lt;https://hydra-url/admin/oauth2/auth/sessions/consent?subject&#x3D;{user}&amp;limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;; rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;, &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will be separated by a comma.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject"></param>
        /// <param name="limit">The maximum amount of consent sessions to be returned, upper bound is 500 sessions. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <returns>List&lt;ClientPreviousConsentSession&gt;</returns>
        List<ClientPreviousConsentSession> ListSubjectConsentSessions(string subject, long? limit = default(long?), long? offset = default(long?));

        /// <summary>
        /// Lists All Consent Sessions of a Subject
        /// </summary>
        /// <remarks>
        /// This endpoint lists all subject&#39;s granted consent sessions, including client and granted scope. If the subject is unknown or has not granted any consent sessions yet, the endpoint returns an empty JSON array with status code 200 OK.   The \&quot;Link\&quot; header is also included in successful responses, which contains one or more links for pagination, formatted like so: &#39;&lt;https://hydra-url/admin/oauth2/auth/sessions/consent?subject&#x3D;{user}&amp;limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;; rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;, &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will be separated by a comma.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject"></param>
        /// <param name="limit">The maximum amount of consent sessions to be returned, upper bound is 500 sessions. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <returns>ApiResponse of List&lt;ClientPreviousConsentSession&gt;</returns>
        ApiResponse<List<ClientPreviousConsentSession>> ListSubjectConsentSessionsWithHttpInfo(string subject, long? limit = default(long?), long? offset = default(long?));
        /// <summary>
        /// List Trusted OAuth2 JWT Bearer Grant Type Issuers
        /// </summary>
        /// <remarks>
        /// Use this endpoint to list all trusted JWT Bearer Grant Type Issuers.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issuer">If optional \&quot;issuer\&quot; is supplied, only jwt-bearer grants with this issuer will be returned. (optional)</param>
        /// <param name="limit">The maximum amount of policies returned, upper bound is 500 policies (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <returns>List&lt;ClientTrustedJwtGrantIssuer&gt;</returns>
        List<ClientTrustedJwtGrantIssuer> ListTrustedJwtGrantIssuers(string issuer = default(string), long? limit = default(long?), long? offset = default(long?));

        /// <summary>
        /// List Trusted OAuth2 JWT Bearer Grant Type Issuers
        /// </summary>
        /// <remarks>
        /// Use this endpoint to list all trusted JWT Bearer Grant Type Issuers.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issuer">If optional \&quot;issuer\&quot; is supplied, only jwt-bearer grants with this issuer will be returned. (optional)</param>
        /// <param name="limit">The maximum amount of policies returned, upper bound is 500 policies (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <returns>ApiResponse of List&lt;ClientTrustedJwtGrantIssuer&gt;</returns>
        ApiResponse<List<ClientTrustedJwtGrantIssuer>> ListTrustedJwtGrantIssuersWithHttpInfo(string issuer = default(string), long? limit = default(long?), long? offset = default(long?));
        /// <summary>
        /// Patch an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Patch an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="clientPatchDocument"></param>
        /// <returns>ClientOAuth2Client</returns>
        ClientOAuth2Client PatchOAuth2Client(string id, List<ClientPatchDocument> clientPatchDocument);

        /// <summary>
        /// Patch an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Patch an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="clientPatchDocument"></param>
        /// <returns>ApiResponse of ClientOAuth2Client</returns>
        ApiResponse<ClientOAuth2Client> PatchOAuth2ClientWithHttpInfo(string id, List<ClientPatchDocument> clientPatchDocument);
        /// <summary>
        /// Reject a Consent Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY Hydra that the subject has not authorized the OAuth 2.0 client to access resources on his/her behalf. The consent provider must include a reason why the consent was not granted.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <returns>ClientCompletedRequest</returns>
        ClientCompletedRequest RejectConsentRequest(string consentChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest));

        /// <summary>
        /// Reject a Consent Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY Hydra that the subject has not authorized the OAuth 2.0 client to access resources on his/her behalf. The consent provider must include a reason why the consent was not granted.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <returns>ApiResponse of ClientCompletedRequest</returns>
        ApiResponse<ClientCompletedRequest> RejectConsentRequestWithHttpInfo(string consentChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest));
        /// <summary>
        /// Reject a Login Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY Hydra that the subject has not authenticated and includes a reason why the authentication was be denied.  The response contains a redirect URL which the login provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <returns>ClientCompletedRequest</returns>
        ClientCompletedRequest RejectLoginRequest(string loginChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest));

        /// <summary>
        /// Reject a Login Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY Hydra that the subject has not authenticated and includes a reason why the authentication was be denied.  The response contains a redirect URL which the login provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <returns>ApiResponse of ClientCompletedRequest</returns>
        ApiResponse<ClientCompletedRequest> RejectLoginRequestWithHttpInfo(string loginChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest));
        /// <summary>
        /// Reject a Logout Request
        /// </summary>
        /// <remarks>
        /// When a user or an application requests ORY Hydra to log out a user, this endpoint is used to deny that logout request. No body is required.  The response is empty as the logout provider has to chose what action to perform next.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <returns></returns>
        void RejectLogoutRequest(string logoutChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest));

        /// <summary>
        /// Reject a Logout Request
        /// </summary>
        /// <remarks>
        /// When a user or an application requests ORY Hydra to log out a user, this endpoint is used to deny that logout request. No body is required.  The response is empty as the logout provider has to chose what action to perform next.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RejectLogoutRequestWithHttpInfo(string logoutChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest));
        /// <summary>
        /// Invalidates All Login Sessions of a Certain User Invalidates a Subject&#39;s Authentication Session
        /// </summary>
        /// <remarks>
        /// This endpoint invalidates a subject&#39;s authentication session. After revoking the authentication session, the subject has to re-authenticate at ORY Hydra. This endpoint does not invalidate any tokens and does not work with OpenID Connect Front- or Back-channel logout.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject"></param>
        /// <returns></returns>
        void RevokeAuthenticationSession(string subject);

        /// <summary>
        /// Invalidates All Login Sessions of a Certain User Invalidates a Subject&#39;s Authentication Session
        /// </summary>
        /// <remarks>
        /// This endpoint invalidates a subject&#39;s authentication session. After revoking the authentication session, the subject has to re-authenticate at ORY Hydra. This endpoint does not invalidate any tokens and does not work with OpenID Connect Front- or Back-channel logout.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RevokeAuthenticationSessionWithHttpInfo(string subject);
        /// <summary>
        /// Revokes Consent Sessions of a Subject for a Specific OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// This endpoint revokes a subject&#39;s granted consent sessions for a specific OAuth 2.0 Client and invalidates all associated OAuth 2.0 Access Tokens.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject">The subject (Subject) who&#39;s consent sessions should be deleted.</param>
        /// <param name="_client">If set, deletes only those consent sessions by the Subject that have been granted to the specified OAuth 2.0 Client ID (optional)</param>
        /// <param name="all">If set to &#x60;?all&#x3D;true&#x60;, deletes all consent sessions by the Subject that have been granted. (optional)</param>
        /// <returns></returns>
        void RevokeConsentSessions(string subject, string _client = default(string), bool? all = default(bool?));

        /// <summary>
        /// Revokes Consent Sessions of a Subject for a Specific OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// This endpoint revokes a subject&#39;s granted consent sessions for a specific OAuth 2.0 Client and invalidates all associated OAuth 2.0 Access Tokens.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject">The subject (Subject) who&#39;s consent sessions should be deleted.</param>
        /// <param name="_client">If set, deletes only those consent sessions by the Subject that have been granted to the specified OAuth 2.0 Client ID (optional)</param>
        /// <param name="all">If set to &#x60;?all&#x3D;true&#x60;, deletes all consent sessions by the Subject that have been granted. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RevokeConsentSessionsWithHttpInfo(string subject, string _client = default(string), bool? all = default(bool?));
        /// <summary>
        /// Trust an OAuth2 JWT Bearer Grant Type Issuer
        /// </summary>
        /// <remarks>
        /// Use this endpoint to establish a trust relationship for a JWT issuer to perform JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523).
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientTrustJwtGrantIssuerBody"> (optional)</param>
        /// <returns>ClientTrustedJwtGrantIssuer</returns>
        ClientTrustedJwtGrantIssuer TrustJwtGrantIssuer(ClientTrustJwtGrantIssuerBody clientTrustJwtGrantIssuerBody = default(ClientTrustJwtGrantIssuerBody));

        /// <summary>
        /// Trust an OAuth2 JWT Bearer Grant Type Issuer
        /// </summary>
        /// <remarks>
        /// Use this endpoint to establish a trust relationship for a JWT issuer to perform JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523).
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientTrustJwtGrantIssuerBody"> (optional)</param>
        /// <returns>ApiResponse of ClientTrustedJwtGrantIssuer</returns>
        ApiResponse<ClientTrustedJwtGrantIssuer> TrustJwtGrantIssuerWithHttpInfo(ClientTrustJwtGrantIssuerBody clientTrustJwtGrantIssuerBody = default(ClientTrustJwtGrantIssuerBody));
        /// <summary>
        /// Update a JSON Web Key
        /// </summary>
        /// <remarks>
        /// Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <param name="clientJSONWebKey"> (optional)</param>
        /// <returns>ClientJSONWebKey</returns>
        ClientJSONWebKey UpdateJsonWebKey(string kid, string set, ClientJSONWebKey clientJSONWebKey = default(ClientJSONWebKey));

        /// <summary>
        /// Update a JSON Web Key
        /// </summary>
        /// <remarks>
        /// Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <param name="clientJSONWebKey"> (optional)</param>
        /// <returns>ApiResponse of ClientJSONWebKey</returns>
        ApiResponse<ClientJSONWebKey> UpdateJsonWebKeyWithHttpInfo(string kid, string set, ClientJSONWebKey clientJSONWebKey = default(ClientJSONWebKey));
        /// <summary>
        /// Update a JSON Web Key Set
        /// </summary>
        /// <remarks>
        /// Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="clientJSONWebKeySet"> (optional)</param>
        /// <returns>ClientJSONWebKeySet</returns>
        ClientJSONWebKeySet UpdateJsonWebKeySet(string set, ClientJSONWebKeySet clientJSONWebKeySet = default(ClientJSONWebKeySet));

        /// <summary>
        /// Update a JSON Web Key Set
        /// </summary>
        /// <remarks>
        /// Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="clientJSONWebKeySet"> (optional)</param>
        /// <returns>ApiResponse of ClientJSONWebKeySet</returns>
        ApiResponse<ClientJSONWebKeySet> UpdateJsonWebKeySetWithHttpInfo(string set, ClientJSONWebKeySet clientJSONWebKeySet = default(ClientJSONWebKeySet));
        /// <summary>
        /// Update an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Update an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="clientOAuth2Client"></param>
        /// <returns>ClientOAuth2Client</returns>
        ClientOAuth2Client UpdateOAuth2Client(string id, ClientOAuth2Client clientOAuth2Client);

        /// <summary>
        /// Update an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Update an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="clientOAuth2Client"></param>
        /// <returns>ApiResponse of ClientOAuth2Client</returns>
        ApiResponse<ClientOAuth2Client> UpdateOAuth2ClientWithHttpInfo(string id, ClientOAuth2Client clientOAuth2Client);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAdminApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Accept a Consent Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY Hydra that the subject has authorized the OAuth 2.0 client to access resources on his/her behalf. The consent provider includes additional information, such as session data for access and ID tokens, and if the consent request should be used as basis for future requests.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="clientAcceptConsentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientCompletedRequest</returns>
        System.Threading.Tasks.Task<ClientCompletedRequest> AcceptConsentRequestAsync(string consentChallenge, ClientAcceptConsentRequest clientAcceptConsentRequest = default(ClientAcceptConsentRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Accept a Consent Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY Hydra that the subject has authorized the OAuth 2.0 client to access resources on his/her behalf. The consent provider includes additional information, such as session data for access and ID tokens, and if the consent request should be used as basis for future requests.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="clientAcceptConsentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientCompletedRequest)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientCompletedRequest>> AcceptConsentRequestWithHttpInfoAsync(string consentChallenge, ClientAcceptConsentRequest clientAcceptConsentRequest = default(ClientAcceptConsentRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Accept a Login Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY Hydra that the subject has successfully authenticated and includes additional information such as the subject&#39;s ID and if ORY Hydra should remember the subject&#39;s subject agent for future authentication attempts by setting a cookie.  The response contains a redirect URL which the login provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="clientAcceptLoginRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientCompletedRequest</returns>
        System.Threading.Tasks.Task<ClientCompletedRequest> AcceptLoginRequestAsync(string loginChallenge, ClientAcceptLoginRequest clientAcceptLoginRequest = default(ClientAcceptLoginRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Accept a Login Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY Hydra that the subject has successfully authenticated and includes additional information such as the subject&#39;s ID and if ORY Hydra should remember the subject&#39;s subject agent for future authentication attempts by setting a cookie.  The response contains a redirect URL which the login provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="clientAcceptLoginRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientCompletedRequest)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientCompletedRequest>> AcceptLoginRequestWithHttpInfoAsync(string loginChallenge, ClientAcceptLoginRequest clientAcceptLoginRequest = default(ClientAcceptLoginRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Accept a Logout Request
        /// </summary>
        /// <remarks>
        /// When a user or an application requests ORY Hydra to log out a user, this endpoint is used to confirm that logout request. No body is required.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientCompletedRequest</returns>
        System.Threading.Tasks.Task<ClientCompletedRequest> AcceptLogoutRequestAsync(string logoutChallenge, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Accept a Logout Request
        /// </summary>
        /// <remarks>
        /// When a user or an application requests ORY Hydra to log out a user, this endpoint is used to confirm that logout request. No body is required.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientCompletedRequest)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientCompletedRequest>> AcceptLogoutRequestWithHttpInfoAsync(string logoutChallenge, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate a New JSON Web Key
        /// </summary>
        /// <remarks>
        /// This endpoint is capable of generating JSON Web Key Sets for you. There a different strategies available, such as symmetric cryptographic keys (HS256, HS512) and asymetric cryptographic keys (RS256, ECDSA). If the specified JSON Web Key Set does not exist, it will be created.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="clientJsonWebKeySetGeneratorRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientJSONWebKeySet</returns>
        System.Threading.Tasks.Task<ClientJSONWebKeySet> CreateJsonWebKeySetAsync(string set, ClientJsonWebKeySetGeneratorRequest clientJsonWebKeySetGeneratorRequest = default(ClientJsonWebKeySetGeneratorRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Generate a New JSON Web Key
        /// </summary>
        /// <remarks>
        /// This endpoint is capable of generating JSON Web Key Sets for you. There a different strategies available, such as symmetric cryptographic keys (HS256, HS512) and asymetric cryptographic keys (RS256, ECDSA). If the specified JSON Web Key Set does not exist, it will be created.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="clientJsonWebKeySetGeneratorRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientJSONWebKeySet)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientJSONWebKeySet>> CreateJsonWebKeySetWithHttpInfoAsync(string set, ClientJsonWebKeySetGeneratorRequest clientJsonWebKeySetGeneratorRequest = default(ClientJsonWebKeySetGeneratorRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Create a new OAuth 2.0 client If you pass &#x60;client_secret&#x60; the secret will be used, otherwise a random secret will be generated. The secret will be returned in the response and you will not be able to retrieve it later on. Write the secret down and keep it somwhere safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientOAuth2Client"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientOAuth2Client</returns>
        System.Threading.Tasks.Task<ClientOAuth2Client> CreateOAuth2ClientAsync(ClientOAuth2Client clientOAuth2Client, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Create a new OAuth 2.0 client If you pass &#x60;client_secret&#x60; the secret will be used, otherwise a random secret will be generated. The secret will be returned in the response and you will not be able to retrieve it later on. Write the secret down and keep it somwhere safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientOAuth2Client"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientOAuth2Client)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientOAuth2Client>> CreateOAuth2ClientWithHttpInfoAsync(ClientOAuth2Client clientOAuth2Client, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a JSON Web Key
        /// </summary>
        /// <remarks>
        /// Use this endpoint to delete a single JSON Web Key.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteJsonWebKeyAsync(string kid, string set, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a JSON Web Key
        /// </summary>
        /// <remarks>
        /// Use this endpoint to delete a single JSON Web Key.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteJsonWebKeyWithHttpInfoAsync(string kid, string set, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a JSON Web Key Set
        /// </summary>
        /// <remarks>
        /// Use this endpoint to delete a complete JSON Web Key Set and all the keys in that set.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteJsonWebKeySetAsync(string set, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a JSON Web Key Set
        /// </summary>
        /// <remarks>
        /// Use this endpoint to delete a complete JSON Web Key Set and all the keys in that set.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteJsonWebKeySetWithHttpInfoAsync(string set, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Deletes an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Delete an existing OAuth 2.0 Client by its ID.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  Make sure that this endpoint is well protected and only callable by first-party components.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteOAuth2ClientAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Deletes an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Delete an existing OAuth 2.0 Client by its ID.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  Make sure that this endpoint is well protected and only callable by first-party components.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteOAuth2ClientWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete OAuth2 Access Tokens from a Client
        /// </summary>
        /// <remarks>
        /// This endpoint deletes OAuth2 access tokens issued for a client from the database
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteOAuth2TokenAsync(string clientId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete OAuth2 Access Tokens from a Client
        /// </summary>
        /// <remarks>
        /// This endpoint deletes OAuth2 access tokens issued for a client from the database
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteOAuth2TokenWithHttpInfoAsync(string clientId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a Trusted OAuth2 JWT Bearer Grant Type Issuer
        /// </summary>
        /// <remarks>
        /// Use this endpoint to delete trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you created the trust relationship.  Once deleted, the associated issuer will no longer be able to perform the JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grant.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the desired grant</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteTrustedJwtGrantIssuerAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a Trusted OAuth2 JWT Bearer Grant Type Issuer
        /// </summary>
        /// <remarks>
        /// Use this endpoint to delete trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you created the trust relationship.  Once deleted, the associated issuer will no longer be able to perform the JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grant.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the desired grant</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteTrustedJwtGrantIssuerWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Flush Expired OAuth2 Access Tokens
        /// </summary>
        /// <remarks>
        /// This endpoint flushes expired OAuth2 access tokens from the database. You can set a time after which no tokens will be not be touched, in case you want to keep recent tokens for auditing. Refresh tokens can not be flushed as they are deleted automatically when performing the refresh flow.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientFlushInactiveOAuth2TokensRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task FlushInactiveOAuth2TokensAsync(ClientFlushInactiveOAuth2TokensRequest clientFlushInactiveOAuth2TokensRequest = default(ClientFlushInactiveOAuth2TokensRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Flush Expired OAuth2 Access Tokens
        /// </summary>
        /// <remarks>
        /// This endpoint flushes expired OAuth2 access tokens from the database. You can set a time after which no tokens will be not be touched, in case you want to keep recent tokens for auditing. Refresh tokens can not be flushed as they are deleted automatically when performing the refresh flow.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientFlushInactiveOAuth2TokensRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> FlushInactiveOAuth2TokensWithHttpInfoAsync(ClientFlushInactiveOAuth2TokensRequest clientFlushInactiveOAuth2TokensRequest = default(ClientFlushInactiveOAuth2TokensRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Consent Request Information
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientConsentRequest</returns>
        System.Threading.Tasks.Task<ClientConsentRequest> GetConsentRequestAsync(string consentChallenge, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Consent Request Information
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientConsentRequest)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientConsentRequest>> GetConsentRequestWithHttpInfoAsync(string consentChallenge, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Fetch a JSON Web Key
        /// </summary>
        /// <remarks>
        /// This endpoint returns a singular JSON Web Key, identified by the set and the specific key ID (kid).
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientJSONWebKeySet</returns>
        System.Threading.Tasks.Task<ClientJSONWebKeySet> GetJsonWebKeyAsync(string kid, string set, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Fetch a JSON Web Key
        /// </summary>
        /// <remarks>
        /// This endpoint returns a singular JSON Web Key, identified by the set and the specific key ID (kid).
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientJSONWebKeySet)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientJSONWebKeySet>> GetJsonWebKeyWithHttpInfoAsync(string kid, string set, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Retrieve a JSON Web Key Set
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to retrieve JWK Sets stored in ORY Hydra.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientJSONWebKeySet</returns>
        System.Threading.Tasks.Task<ClientJSONWebKeySet> GetJsonWebKeySetAsync(string set, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Retrieve a JSON Web Key Set
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to retrieve JWK Sets stored in ORY Hydra.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientJSONWebKeySet)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientJSONWebKeySet>> GetJsonWebKeySetWithHttpInfoAsync(string set, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a Login Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientLoginRequest</returns>
        System.Threading.Tasks.Task<ClientLoginRequest> GetLoginRequestAsync(string loginChallenge, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a Login Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientLoginRequest)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientLoginRequest>> GetLoginRequestWithHttpInfoAsync(string loginChallenge, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a Logout Request
        /// </summary>
        /// <remarks>
        /// Use this endpoint to fetch a logout request.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientLogoutRequest</returns>
        System.Threading.Tasks.Task<ClientLogoutRequest> GetLogoutRequestAsync(string logoutChallenge, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a Logout Request
        /// </summary>
        /// <remarks>
        /// Use this endpoint to fetch a logout request.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientLogoutRequest)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientLogoutRequest>> GetLogoutRequestWithHttpInfoAsync(string logoutChallenge, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Get an OAuth 2.0 client by its ID. This endpoint never returns the client secret.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientOAuth2Client</returns>
        System.Threading.Tasks.Task<ClientOAuth2Client> GetOAuth2ClientAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Get an OAuth 2.0 client by its ID. This endpoint never returns the client secret.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientOAuth2Client)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientOAuth2Client>> GetOAuth2ClientWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a Trusted OAuth2 JWT Bearer Grant Type Issuer
        /// </summary>
        /// <remarks>
        /// Use this endpoint to get a trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you created the trust relationship.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the desired grant</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientTrustedJwtGrantIssuer</returns>
        System.Threading.Tasks.Task<ClientTrustedJwtGrantIssuer> GetTrustedJwtGrantIssuerAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a Trusted OAuth2 JWT Bearer Grant Type Issuer
        /// </summary>
        /// <remarks>
        /// Use this endpoint to get a trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you created the trust relationship.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the desired grant</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientTrustedJwtGrantIssuer)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientTrustedJwtGrantIssuer>> GetTrustedJwtGrantIssuerWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Introspect OAuth2 Tokens
        /// </summary>
        /// <remarks>
        /// The introspection endpoint allows to check if a token (both refresh and access) is active or not. An active token is neither expired nor revoked. If a token is active, additional information on the token will be included. You can set additional data for a token by setting &#x60;accessTokenExtra&#x60; during the consent flow.  For more information [read this blog post](https://www.oauth.com/oauth2-servers/token-introspection-endpoint/).
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The string value of the token. For access tokens, this is the \\\&quot;access_token\\\&quot; value returned from the token endpoint defined in OAuth 2.0. For refresh tokens, this is the \\\&quot;refresh_token\\\&quot; value returned.</param>
        /// <param name="scope">An optional, space separated list of required scopes. If the access token was not granted one of the scopes, the result of active will be false. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientOAuth2TokenIntrospection</returns>
        System.Threading.Tasks.Task<ClientOAuth2TokenIntrospection> IntrospectOAuth2TokenAsync(string token, string scope = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Introspect OAuth2 Tokens
        /// </summary>
        /// <remarks>
        /// The introspection endpoint allows to check if a token (both refresh and access) is active or not. An active token is neither expired nor revoked. If a token is active, additional information on the token will be included. You can set additional data for a token by setting &#x60;accessTokenExtra&#x60; during the consent flow.  For more information [read this blog post](https://www.oauth.com/oauth2-servers/token-introspection-endpoint/).
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The string value of the token. For access tokens, this is the \\\&quot;access_token\\\&quot; value returned from the token endpoint defined in OAuth 2.0. For refresh tokens, this is the \\\&quot;refresh_token\\\&quot; value returned.</param>
        /// <param name="scope">An optional, space separated list of required scopes. If the access token was not granted one of the scopes, the result of active will be false. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientOAuth2TokenIntrospection)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientOAuth2TokenIntrospection>> IntrospectOAuth2TokenWithHttpInfoAsync(string token, string scope = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List OAuth 2.0 Clients
        /// </summary>
        /// <remarks>
        /// This endpoint lists all clients in the database, and never returns client secrets. As a default it lists the first 100 clients. The &#x60;limit&#x60; parameter can be used to retrieve more clients, but it has an upper bound at 500 objects. Pagination should be used to retrieve more than 500 objects.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  The \&quot;Link\&quot; header is also included in successful responses, which contains one or more links for pagination, formatted like so: &#39;&lt;https://hydra-url/admin/clients?limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;; rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;, &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will be separated by a comma.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">The maximum amount of clients to returned, upper bound is 500 clients. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="clientName">The name of the clients to filter by. (optional)</param>
        /// <param name="owner">The owner of the clients to filter by. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ClientOAuth2Client&gt;</returns>
        System.Threading.Tasks.Task<List<ClientOAuth2Client>> ListOAuth2ClientsAsync(long? limit = default(long?), long? offset = default(long?), string clientName = default(string), string owner = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List OAuth 2.0 Clients
        /// </summary>
        /// <remarks>
        /// This endpoint lists all clients in the database, and never returns client secrets. As a default it lists the first 100 clients. The &#x60;limit&#x60; parameter can be used to retrieve more clients, but it has an upper bound at 500 objects. Pagination should be used to retrieve more than 500 objects.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  The \&quot;Link\&quot; header is also included in successful responses, which contains one or more links for pagination, formatted like so: &#39;&lt;https://hydra-url/admin/clients?limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;; rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;, &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will be separated by a comma.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">The maximum amount of clients to returned, upper bound is 500 clients. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="clientName">The name of the clients to filter by. (optional)</param>
        /// <param name="owner">The owner of the clients to filter by. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ClientOAuth2Client&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<ClientOAuth2Client>>> ListOAuth2ClientsWithHttpInfoAsync(long? limit = default(long?), long? offset = default(long?), string clientName = default(string), string owner = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Lists All Consent Sessions of a Subject
        /// </summary>
        /// <remarks>
        /// This endpoint lists all subject&#39;s granted consent sessions, including client and granted scope. If the subject is unknown or has not granted any consent sessions yet, the endpoint returns an empty JSON array with status code 200 OK.   The \&quot;Link\&quot; header is also included in successful responses, which contains one or more links for pagination, formatted like so: &#39;&lt;https://hydra-url/admin/oauth2/auth/sessions/consent?subject&#x3D;{user}&amp;limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;; rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;, &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will be separated by a comma.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject"></param>
        /// <param name="limit">The maximum amount of consent sessions to be returned, upper bound is 500 sessions. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ClientPreviousConsentSession&gt;</returns>
        System.Threading.Tasks.Task<List<ClientPreviousConsentSession>> ListSubjectConsentSessionsAsync(string subject, long? limit = default(long?), long? offset = default(long?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Lists All Consent Sessions of a Subject
        /// </summary>
        /// <remarks>
        /// This endpoint lists all subject&#39;s granted consent sessions, including client and granted scope. If the subject is unknown or has not granted any consent sessions yet, the endpoint returns an empty JSON array with status code 200 OK.   The \&quot;Link\&quot; header is also included in successful responses, which contains one or more links for pagination, formatted like so: &#39;&lt;https://hydra-url/admin/oauth2/auth/sessions/consent?subject&#x3D;{user}&amp;limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;; rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;, &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will be separated by a comma.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject"></param>
        /// <param name="limit">The maximum amount of consent sessions to be returned, upper bound is 500 sessions. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ClientPreviousConsentSession&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<ClientPreviousConsentSession>>> ListSubjectConsentSessionsWithHttpInfoAsync(string subject, long? limit = default(long?), long? offset = default(long?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List Trusted OAuth2 JWT Bearer Grant Type Issuers
        /// </summary>
        /// <remarks>
        /// Use this endpoint to list all trusted JWT Bearer Grant Type Issuers.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issuer">If optional \&quot;issuer\&quot; is supplied, only jwt-bearer grants with this issuer will be returned. (optional)</param>
        /// <param name="limit">The maximum amount of policies returned, upper bound is 500 policies (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ClientTrustedJwtGrantIssuer&gt;</returns>
        System.Threading.Tasks.Task<List<ClientTrustedJwtGrantIssuer>> ListTrustedJwtGrantIssuersAsync(string issuer = default(string), long? limit = default(long?), long? offset = default(long?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List Trusted OAuth2 JWT Bearer Grant Type Issuers
        /// </summary>
        /// <remarks>
        /// Use this endpoint to list all trusted JWT Bearer Grant Type Issuers.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issuer">If optional \&quot;issuer\&quot; is supplied, only jwt-bearer grants with this issuer will be returned. (optional)</param>
        /// <param name="limit">The maximum amount of policies returned, upper bound is 500 policies (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ClientTrustedJwtGrantIssuer&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<ClientTrustedJwtGrantIssuer>>> ListTrustedJwtGrantIssuersWithHttpInfoAsync(string issuer = default(string), long? limit = default(long?), long? offset = default(long?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Patch an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Patch an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="clientPatchDocument"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientOAuth2Client</returns>
        System.Threading.Tasks.Task<ClientOAuth2Client> PatchOAuth2ClientAsync(string id, List<ClientPatchDocument> clientPatchDocument, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Patch an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Patch an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="clientPatchDocument"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientOAuth2Client)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientOAuth2Client>> PatchOAuth2ClientWithHttpInfoAsync(string id, List<ClientPatchDocument> clientPatchDocument, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Reject a Consent Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY Hydra that the subject has not authorized the OAuth 2.0 client to access resources on his/her behalf. The consent provider must include a reason why the consent was not granted.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientCompletedRequest</returns>
        System.Threading.Tasks.Task<ClientCompletedRequest> RejectConsentRequestAsync(string consentChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Reject a Consent Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY Hydra that the subject has not authorized the OAuth 2.0 client to access resources on his/her behalf. The consent provider must include a reason why the consent was not granted.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientCompletedRequest)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientCompletedRequest>> RejectConsentRequestWithHttpInfoAsync(string consentChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Reject a Login Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY Hydra that the subject has not authenticated and includes a reason why the authentication was be denied.  The response contains a redirect URL which the login provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientCompletedRequest</returns>
        System.Threading.Tasks.Task<ClientCompletedRequest> RejectLoginRequestAsync(string loginChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Reject a Login Request
        /// </summary>
        /// <remarks>
        /// When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY Hydra that the subject has not authenticated and includes a reason why the authentication was be denied.  The response contains a redirect URL which the login provider should redirect the user-agent to.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientCompletedRequest)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientCompletedRequest>> RejectLoginRequestWithHttpInfoAsync(string loginChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Reject a Logout Request
        /// </summary>
        /// <remarks>
        /// When a user or an application requests ORY Hydra to log out a user, this endpoint is used to deny that logout request. No body is required.  The response is empty as the logout provider has to chose what action to perform next.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RejectLogoutRequestAsync(string logoutChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Reject a Logout Request
        /// </summary>
        /// <remarks>
        /// When a user or an application requests ORY Hydra to log out a user, this endpoint is used to deny that logout request. No body is required.  The response is empty as the logout provider has to chose what action to perform next.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RejectLogoutRequestWithHttpInfoAsync(string logoutChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invalidates All Login Sessions of a Certain User Invalidates a Subject&#39;s Authentication Session
        /// </summary>
        /// <remarks>
        /// This endpoint invalidates a subject&#39;s authentication session. After revoking the authentication session, the subject has to re-authenticate at ORY Hydra. This endpoint does not invalidate any tokens and does not work with OpenID Connect Front- or Back-channel logout.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RevokeAuthenticationSessionAsync(string subject, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Invalidates All Login Sessions of a Certain User Invalidates a Subject&#39;s Authentication Session
        /// </summary>
        /// <remarks>
        /// This endpoint invalidates a subject&#39;s authentication session. After revoking the authentication session, the subject has to re-authenticate at ORY Hydra. This endpoint does not invalidate any tokens and does not work with OpenID Connect Front- or Back-channel logout.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RevokeAuthenticationSessionWithHttpInfoAsync(string subject, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Revokes Consent Sessions of a Subject for a Specific OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// This endpoint revokes a subject&#39;s granted consent sessions for a specific OAuth 2.0 Client and invalidates all associated OAuth 2.0 Access Tokens.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject">The subject (Subject) who&#39;s consent sessions should be deleted.</param>
        /// <param name="_client">If set, deletes only those consent sessions by the Subject that have been granted to the specified OAuth 2.0 Client ID (optional)</param>
        /// <param name="all">If set to &#x60;?all&#x3D;true&#x60;, deletes all consent sessions by the Subject that have been granted. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RevokeConsentSessionsAsync(string subject, string _client = default(string), bool? all = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Revokes Consent Sessions of a Subject for a Specific OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// This endpoint revokes a subject&#39;s granted consent sessions for a specific OAuth 2.0 Client and invalidates all associated OAuth 2.0 Access Tokens.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject">The subject (Subject) who&#39;s consent sessions should be deleted.</param>
        /// <param name="_client">If set, deletes only those consent sessions by the Subject that have been granted to the specified OAuth 2.0 Client ID (optional)</param>
        /// <param name="all">If set to &#x60;?all&#x3D;true&#x60;, deletes all consent sessions by the Subject that have been granted. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RevokeConsentSessionsWithHttpInfoAsync(string subject, string _client = default(string), bool? all = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Trust an OAuth2 JWT Bearer Grant Type Issuer
        /// </summary>
        /// <remarks>
        /// Use this endpoint to establish a trust relationship for a JWT issuer to perform JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523).
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientTrustJwtGrantIssuerBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientTrustedJwtGrantIssuer</returns>
        System.Threading.Tasks.Task<ClientTrustedJwtGrantIssuer> TrustJwtGrantIssuerAsync(ClientTrustJwtGrantIssuerBody clientTrustJwtGrantIssuerBody = default(ClientTrustJwtGrantIssuerBody), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Trust an OAuth2 JWT Bearer Grant Type Issuer
        /// </summary>
        /// <remarks>
        /// Use this endpoint to establish a trust relationship for a JWT issuer to perform JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523).
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientTrustJwtGrantIssuerBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientTrustedJwtGrantIssuer)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientTrustedJwtGrantIssuer>> TrustJwtGrantIssuerWithHttpInfoAsync(ClientTrustJwtGrantIssuerBody clientTrustJwtGrantIssuerBody = default(ClientTrustJwtGrantIssuerBody), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update a JSON Web Key
        /// </summary>
        /// <remarks>
        /// Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <param name="clientJSONWebKey"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientJSONWebKey</returns>
        System.Threading.Tasks.Task<ClientJSONWebKey> UpdateJsonWebKeyAsync(string kid, string set, ClientJSONWebKey clientJSONWebKey = default(ClientJSONWebKey), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Update a JSON Web Key
        /// </summary>
        /// <remarks>
        /// Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <param name="clientJSONWebKey"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientJSONWebKey)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientJSONWebKey>> UpdateJsonWebKeyWithHttpInfoAsync(string kid, string set, ClientJSONWebKey clientJSONWebKey = default(ClientJSONWebKey), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update a JSON Web Key Set
        /// </summary>
        /// <remarks>
        /// Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="clientJSONWebKeySet"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientJSONWebKeySet</returns>
        System.Threading.Tasks.Task<ClientJSONWebKeySet> UpdateJsonWebKeySetAsync(string set, ClientJSONWebKeySet clientJSONWebKeySet = default(ClientJSONWebKeySet), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Update a JSON Web Key Set
        /// </summary>
        /// <remarks>
        /// Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="clientJSONWebKeySet"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientJSONWebKeySet)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientJSONWebKeySet>> UpdateJsonWebKeySetWithHttpInfoAsync(string set, ClientJSONWebKeySet clientJSONWebKeySet = default(ClientJSONWebKeySet), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Update an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="clientOAuth2Client"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientOAuth2Client</returns>
        System.Threading.Tasks.Task<ClientOAuth2Client> UpdateOAuth2ClientAsync(string id, ClientOAuth2Client clientOAuth2Client, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Update an OAuth 2.0 Client
        /// </summary>
        /// <remarks>
        /// Update an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </remarks>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="clientOAuth2Client"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientOAuth2Client)</returns>
        System.Threading.Tasks.Task<ApiResponse<ClientOAuth2Client>> UpdateOAuth2ClientWithHttpInfoAsync(string id, ClientOAuth2Client clientOAuth2Client, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAdminApi : IAdminApiSync, IAdminApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class AdminApi : IAdminApi
    {
        private Ory.Client.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="AdminApi"/> class.
        /// </summary>
        /// <returns></returns>
        public AdminApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AdminApi"/> class.
        /// </summary>
        /// <returns></returns>
        public AdminApi(string basePath)
        {
            this.Configuration = Ory.Client.Client.Configuration.MergeConfigurations(
                Ory.Client.Client.GlobalConfiguration.Instance,
                new Ory.Client.Client.Configuration { BasePath = basePath }
            );
            this.Client = new Ory.Client.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Ory.Client.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Ory.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AdminApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public AdminApi(Ory.Client.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Ory.Client.Client.Configuration.MergeConfigurations(
                Ory.Client.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new Ory.Client.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Ory.Client.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Ory.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AdminApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public AdminApi(Ory.Client.Client.ISynchronousClient client, Ory.Client.Client.IAsynchronousClient asyncClient, Ory.Client.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Ory.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Ory.Client.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Ory.Client.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Ory.Client.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Ory.Client.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Accept a Consent Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY Hydra that the subject has authorized the OAuth 2.0 client to access resources on his/her behalf. The consent provider includes additional information, such as session data for access and ID tokens, and if the consent request should be used as basis for future requests.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="clientAcceptConsentRequest"> (optional)</param>
        /// <returns>ClientCompletedRequest</returns>
        public ClientCompletedRequest AcceptConsentRequest(string consentChallenge, ClientAcceptConsentRequest clientAcceptConsentRequest = default(ClientAcceptConsentRequest))
        {
            Ory.Client.Client.ApiResponse<ClientCompletedRequest> localVarResponse = AcceptConsentRequestWithHttpInfo(consentChallenge, clientAcceptConsentRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Accept a Consent Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY Hydra that the subject has authorized the OAuth 2.0 client to access resources on his/her behalf. The consent provider includes additional information, such as session data for access and ID tokens, and if the consent request should be used as basis for future requests.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="clientAcceptConsentRequest"> (optional)</param>
        /// <returns>ApiResponse of ClientCompletedRequest</returns>
        public Ory.Client.Client.ApiResponse<ClientCompletedRequest> AcceptConsentRequestWithHttpInfo(string consentChallenge, ClientAcceptConsentRequest clientAcceptConsentRequest = default(ClientAcceptConsentRequest))
        {
            // verify the required parameter 'consentChallenge' is set
            if (consentChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'consentChallenge' when calling AdminApi->AcceptConsentRequest");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "consent_challenge", consentChallenge));
            localVarRequestOptions.Data = clientAcceptConsentRequest;


            // make the HTTP request
            var localVarResponse = this.Client.Put<ClientCompletedRequest>("/oauth2/auth/requests/consent/accept", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AcceptConsentRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Accept a Consent Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY Hydra that the subject has authorized the OAuth 2.0 client to access resources on his/her behalf. The consent provider includes additional information, such as session data for access and ID tokens, and if the consent request should be used as basis for future requests.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="clientAcceptConsentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientCompletedRequest</returns>
        public async System.Threading.Tasks.Task<ClientCompletedRequest> AcceptConsentRequestAsync(string consentChallenge, ClientAcceptConsentRequest clientAcceptConsentRequest = default(ClientAcceptConsentRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientCompletedRequest> localVarResponse = await AcceptConsentRequestWithHttpInfoAsync(consentChallenge, clientAcceptConsentRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Accept a Consent Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY Hydra that the subject has authorized the OAuth 2.0 client to access resources on his/her behalf. The consent provider includes additional information, such as session data for access and ID tokens, and if the consent request should be used as basis for future requests.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="clientAcceptConsentRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientCompletedRequest)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientCompletedRequest>> AcceptConsentRequestWithHttpInfoAsync(string consentChallenge, ClientAcceptConsentRequest clientAcceptConsentRequest = default(ClientAcceptConsentRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'consentChallenge' is set
            if (consentChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'consentChallenge' when calling AdminApi->AcceptConsentRequest");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "consent_challenge", consentChallenge));
            localVarRequestOptions.Data = clientAcceptConsentRequest;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<ClientCompletedRequest>("/oauth2/auth/requests/consent/accept", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AcceptConsentRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Accept a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY Hydra that the subject has successfully authenticated and includes additional information such as the subject&#39;s ID and if ORY Hydra should remember the subject&#39;s subject agent for future authentication attempts by setting a cookie.  The response contains a redirect URL which the login provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="clientAcceptLoginRequest"> (optional)</param>
        /// <returns>ClientCompletedRequest</returns>
        public ClientCompletedRequest AcceptLoginRequest(string loginChallenge, ClientAcceptLoginRequest clientAcceptLoginRequest = default(ClientAcceptLoginRequest))
        {
            Ory.Client.Client.ApiResponse<ClientCompletedRequest> localVarResponse = AcceptLoginRequestWithHttpInfo(loginChallenge, clientAcceptLoginRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Accept a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY Hydra that the subject has successfully authenticated and includes additional information such as the subject&#39;s ID and if ORY Hydra should remember the subject&#39;s subject agent for future authentication attempts by setting a cookie.  The response contains a redirect URL which the login provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="clientAcceptLoginRequest"> (optional)</param>
        /// <returns>ApiResponse of ClientCompletedRequest</returns>
        public Ory.Client.Client.ApiResponse<ClientCompletedRequest> AcceptLoginRequestWithHttpInfo(string loginChallenge, ClientAcceptLoginRequest clientAcceptLoginRequest = default(ClientAcceptLoginRequest))
        {
            // verify the required parameter 'loginChallenge' is set
            if (loginChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'loginChallenge' when calling AdminApi->AcceptLoginRequest");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "login_challenge", loginChallenge));
            localVarRequestOptions.Data = clientAcceptLoginRequest;


            // make the HTTP request
            var localVarResponse = this.Client.Put<ClientCompletedRequest>("/oauth2/auth/requests/login/accept", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AcceptLoginRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Accept a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY Hydra that the subject has successfully authenticated and includes additional information such as the subject&#39;s ID and if ORY Hydra should remember the subject&#39;s subject agent for future authentication attempts by setting a cookie.  The response contains a redirect URL which the login provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="clientAcceptLoginRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientCompletedRequest</returns>
        public async System.Threading.Tasks.Task<ClientCompletedRequest> AcceptLoginRequestAsync(string loginChallenge, ClientAcceptLoginRequest clientAcceptLoginRequest = default(ClientAcceptLoginRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientCompletedRequest> localVarResponse = await AcceptLoginRequestWithHttpInfoAsync(loginChallenge, clientAcceptLoginRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Accept a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY Hydra that the subject has successfully authenticated and includes additional information such as the subject&#39;s ID and if ORY Hydra should remember the subject&#39;s subject agent for future authentication attempts by setting a cookie.  The response contains a redirect URL which the login provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="clientAcceptLoginRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientCompletedRequest)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientCompletedRequest>> AcceptLoginRequestWithHttpInfoAsync(string loginChallenge, ClientAcceptLoginRequest clientAcceptLoginRequest = default(ClientAcceptLoginRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'loginChallenge' is set
            if (loginChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'loginChallenge' when calling AdminApi->AcceptLoginRequest");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "login_challenge", loginChallenge));
            localVarRequestOptions.Data = clientAcceptLoginRequest;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<ClientCompletedRequest>("/oauth2/auth/requests/login/accept", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AcceptLoginRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Accept a Logout Request When a user or an application requests ORY Hydra to log out a user, this endpoint is used to confirm that logout request. No body is required.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <returns>ClientCompletedRequest</returns>
        public ClientCompletedRequest AcceptLogoutRequest(string logoutChallenge)
        {
            Ory.Client.Client.ApiResponse<ClientCompletedRequest> localVarResponse = AcceptLogoutRequestWithHttpInfo(logoutChallenge);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Accept a Logout Request When a user or an application requests ORY Hydra to log out a user, this endpoint is used to confirm that logout request. No body is required.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <returns>ApiResponse of ClientCompletedRequest</returns>
        public Ory.Client.Client.ApiResponse<ClientCompletedRequest> AcceptLogoutRequestWithHttpInfo(string logoutChallenge)
        {
            // verify the required parameter 'logoutChallenge' is set
            if (logoutChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'logoutChallenge' when calling AdminApi->AcceptLogoutRequest");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "logout_challenge", logoutChallenge));


            // make the HTTP request
            var localVarResponse = this.Client.Put<ClientCompletedRequest>("/oauth2/auth/requests/logout/accept", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AcceptLogoutRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Accept a Logout Request When a user or an application requests ORY Hydra to log out a user, this endpoint is used to confirm that logout request. No body is required.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientCompletedRequest</returns>
        public async System.Threading.Tasks.Task<ClientCompletedRequest> AcceptLogoutRequestAsync(string logoutChallenge, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientCompletedRequest> localVarResponse = await AcceptLogoutRequestWithHttpInfoAsync(logoutChallenge, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Accept a Logout Request When a user or an application requests ORY Hydra to log out a user, this endpoint is used to confirm that logout request. No body is required.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientCompletedRequest)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientCompletedRequest>> AcceptLogoutRequestWithHttpInfoAsync(string logoutChallenge, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'logoutChallenge' is set
            if (logoutChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'logoutChallenge' when calling AdminApi->AcceptLogoutRequest");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "logout_challenge", logoutChallenge));


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<ClientCompletedRequest>("/oauth2/auth/requests/logout/accept", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AcceptLogoutRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Generate a New JSON Web Key This endpoint is capable of generating JSON Web Key Sets for you. There a different strategies available, such as symmetric cryptographic keys (HS256, HS512) and asymetric cryptographic keys (RS256, ECDSA). If the specified JSON Web Key Set does not exist, it will be created.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="clientJsonWebKeySetGeneratorRequest"> (optional)</param>
        /// <returns>ClientJSONWebKeySet</returns>
        public ClientJSONWebKeySet CreateJsonWebKeySet(string set, ClientJsonWebKeySetGeneratorRequest clientJsonWebKeySetGeneratorRequest = default(ClientJsonWebKeySetGeneratorRequest))
        {
            Ory.Client.Client.ApiResponse<ClientJSONWebKeySet> localVarResponse = CreateJsonWebKeySetWithHttpInfo(set, clientJsonWebKeySetGeneratorRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate a New JSON Web Key This endpoint is capable of generating JSON Web Key Sets for you. There a different strategies available, such as symmetric cryptographic keys (HS256, HS512) and asymetric cryptographic keys (RS256, ECDSA). If the specified JSON Web Key Set does not exist, it will be created.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="clientJsonWebKeySetGeneratorRequest"> (optional)</param>
        /// <returns>ApiResponse of ClientJSONWebKeySet</returns>
        public Ory.Client.Client.ApiResponse<ClientJSONWebKeySet> CreateJsonWebKeySetWithHttpInfo(string set, ClientJsonWebKeySetGeneratorRequest clientJsonWebKeySetGeneratorRequest = default(ClientJsonWebKeySetGeneratorRequest))
        {
            // verify the required parameter 'set' is set
            if (set == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'set' when calling AdminApi->CreateJsonWebKeySet");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("set", Ory.Client.Client.ClientUtils.ParameterToString(set)); // path parameter
            localVarRequestOptions.Data = clientJsonWebKeySetGeneratorRequest;


            // make the HTTP request
            var localVarResponse = this.Client.Post<ClientJSONWebKeySet>("/keys/{set}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateJsonWebKeySet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Generate a New JSON Web Key This endpoint is capable of generating JSON Web Key Sets for you. There a different strategies available, such as symmetric cryptographic keys (HS256, HS512) and asymetric cryptographic keys (RS256, ECDSA). If the specified JSON Web Key Set does not exist, it will be created.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="clientJsonWebKeySetGeneratorRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientJSONWebKeySet</returns>
        public async System.Threading.Tasks.Task<ClientJSONWebKeySet> CreateJsonWebKeySetAsync(string set, ClientJsonWebKeySetGeneratorRequest clientJsonWebKeySetGeneratorRequest = default(ClientJsonWebKeySetGeneratorRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientJSONWebKeySet> localVarResponse = await CreateJsonWebKeySetWithHttpInfoAsync(set, clientJsonWebKeySetGeneratorRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate a New JSON Web Key This endpoint is capable of generating JSON Web Key Sets for you. There a different strategies available, such as symmetric cryptographic keys (HS256, HS512) and asymetric cryptographic keys (RS256, ECDSA). If the specified JSON Web Key Set does not exist, it will be created.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="clientJsonWebKeySetGeneratorRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientJSONWebKeySet)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientJSONWebKeySet>> CreateJsonWebKeySetWithHttpInfoAsync(string set, ClientJsonWebKeySetGeneratorRequest clientJsonWebKeySetGeneratorRequest = default(ClientJsonWebKeySetGeneratorRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'set' is set
            if (set == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'set' when calling AdminApi->CreateJsonWebKeySet");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("set", Ory.Client.Client.ClientUtils.ParameterToString(set)); // path parameter
            localVarRequestOptions.Data = clientJsonWebKeySetGeneratorRequest;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ClientJSONWebKeySet>("/keys/{set}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateJsonWebKeySet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an OAuth 2.0 Client Create a new OAuth 2.0 client If you pass &#x60;client_secret&#x60; the secret will be used, otherwise a random secret will be generated. The secret will be returned in the response and you will not be able to retrieve it later on. Write the secret down and keep it somwhere safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientOAuth2Client"></param>
        /// <returns>ClientOAuth2Client</returns>
        public ClientOAuth2Client CreateOAuth2Client(ClientOAuth2Client clientOAuth2Client)
        {
            Ory.Client.Client.ApiResponse<ClientOAuth2Client> localVarResponse = CreateOAuth2ClientWithHttpInfo(clientOAuth2Client);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create an OAuth 2.0 Client Create a new OAuth 2.0 client If you pass &#x60;client_secret&#x60; the secret will be used, otherwise a random secret will be generated. The secret will be returned in the response and you will not be able to retrieve it later on. Write the secret down and keep it somwhere safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientOAuth2Client"></param>
        /// <returns>ApiResponse of ClientOAuth2Client</returns>
        public Ory.Client.Client.ApiResponse<ClientOAuth2Client> CreateOAuth2ClientWithHttpInfo(ClientOAuth2Client clientOAuth2Client)
        {
            // verify the required parameter 'clientOAuth2Client' is set
            if (clientOAuth2Client == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'clientOAuth2Client' when calling AdminApi->CreateOAuth2Client");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = clientOAuth2Client;


            // make the HTTP request
            var localVarResponse = this.Client.Post<ClientOAuth2Client>("/clients", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateOAuth2Client", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an OAuth 2.0 Client Create a new OAuth 2.0 client If you pass &#x60;client_secret&#x60; the secret will be used, otherwise a random secret will be generated. The secret will be returned in the response and you will not be able to retrieve it later on. Write the secret down and keep it somwhere safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientOAuth2Client"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientOAuth2Client</returns>
        public async System.Threading.Tasks.Task<ClientOAuth2Client> CreateOAuth2ClientAsync(ClientOAuth2Client clientOAuth2Client, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientOAuth2Client> localVarResponse = await CreateOAuth2ClientWithHttpInfoAsync(clientOAuth2Client, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create an OAuth 2.0 Client Create a new OAuth 2.0 client If you pass &#x60;client_secret&#x60; the secret will be used, otherwise a random secret will be generated. The secret will be returned in the response and you will not be able to retrieve it later on. Write the secret down and keep it somwhere safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientOAuth2Client"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientOAuth2Client)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientOAuth2Client>> CreateOAuth2ClientWithHttpInfoAsync(ClientOAuth2Client clientOAuth2Client, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'clientOAuth2Client' is set
            if (clientOAuth2Client == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'clientOAuth2Client' when calling AdminApi->CreateOAuth2Client");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = clientOAuth2Client;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ClientOAuth2Client>("/clients", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateOAuth2Client", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a JSON Web Key Use this endpoint to delete a single JSON Web Key.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <returns></returns>
        public void DeleteJsonWebKey(string kid, string set)
        {
            DeleteJsonWebKeyWithHttpInfo(kid, set);
        }

        /// <summary>
        /// Delete a JSON Web Key Use this endpoint to delete a single JSON Web Key.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Ory.Client.Client.ApiResponse<Object> DeleteJsonWebKeyWithHttpInfo(string kid, string set)
        {
            // verify the required parameter 'kid' is set
            if (kid == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'kid' when calling AdminApi->DeleteJsonWebKey");
            }

            // verify the required parameter 'set' is set
            if (set == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'set' when calling AdminApi->DeleteJsonWebKey");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("kid", Ory.Client.Client.ClientUtils.ParameterToString(kid)); // path parameter
            localVarRequestOptions.PathParameters.Add("set", Ory.Client.Client.ClientUtils.ParameterToString(set)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/keys/{set}/{kid}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteJsonWebKey", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a JSON Web Key Use this endpoint to delete a single JSON Web Key.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteJsonWebKeyAsync(string kid, string set, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteJsonWebKeyWithHttpInfoAsync(kid, set, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a JSON Web Key Use this endpoint to delete a single JSON Web Key.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<Object>> DeleteJsonWebKeyWithHttpInfoAsync(string kid, string set, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'kid' is set
            if (kid == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'kid' when calling AdminApi->DeleteJsonWebKey");
            }

            // verify the required parameter 'set' is set
            if (set == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'set' when calling AdminApi->DeleteJsonWebKey");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("kid", Ory.Client.Client.ClientUtils.ParameterToString(kid)); // path parameter
            localVarRequestOptions.PathParameters.Add("set", Ory.Client.Client.ClientUtils.ParameterToString(set)); // path parameter


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/keys/{set}/{kid}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteJsonWebKey", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a JSON Web Key Set Use this endpoint to delete a complete JSON Web Key Set and all the keys in that set.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <returns></returns>
        public void DeleteJsonWebKeySet(string set)
        {
            DeleteJsonWebKeySetWithHttpInfo(set);
        }

        /// <summary>
        /// Delete a JSON Web Key Set Use this endpoint to delete a complete JSON Web Key Set and all the keys in that set.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Ory.Client.Client.ApiResponse<Object> DeleteJsonWebKeySetWithHttpInfo(string set)
        {
            // verify the required parameter 'set' is set
            if (set == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'set' when calling AdminApi->DeleteJsonWebKeySet");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("set", Ory.Client.Client.ClientUtils.ParameterToString(set)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/keys/{set}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteJsonWebKeySet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a JSON Web Key Set Use this endpoint to delete a complete JSON Web Key Set and all the keys in that set.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteJsonWebKeySetAsync(string set, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteJsonWebKeySetWithHttpInfoAsync(set, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a JSON Web Key Set Use this endpoint to delete a complete JSON Web Key Set and all the keys in that set.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<Object>> DeleteJsonWebKeySetWithHttpInfoAsync(string set, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'set' is set
            if (set == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'set' when calling AdminApi->DeleteJsonWebKeySet");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("set", Ory.Client.Client.ClientUtils.ParameterToString(set)); // path parameter


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/keys/{set}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteJsonWebKeySet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes an OAuth 2.0 Client Delete an existing OAuth 2.0 Client by its ID.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  Make sure that this endpoint is well protected and only callable by first-party components.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <returns></returns>
        public void DeleteOAuth2Client(string id)
        {
            DeleteOAuth2ClientWithHttpInfo(id);
        }

        /// <summary>
        /// Deletes an OAuth 2.0 Client Delete an existing OAuth 2.0 Client by its ID.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  Make sure that this endpoint is well protected and only callable by first-party components.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Ory.Client.Client.ApiResponse<Object> DeleteOAuth2ClientWithHttpInfo(string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'id' when calling AdminApi->DeleteOAuth2Client");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Ory.Client.Client.ClientUtils.ParameterToString(id)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/clients/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteOAuth2Client", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Deletes an OAuth 2.0 Client Delete an existing OAuth 2.0 Client by its ID.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  Make sure that this endpoint is well protected and only callable by first-party components.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteOAuth2ClientAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteOAuth2ClientWithHttpInfoAsync(id, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Deletes an OAuth 2.0 Client Delete an existing OAuth 2.0 Client by its ID.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  Make sure that this endpoint is well protected and only callable by first-party components.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<Object>> DeleteOAuth2ClientWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'id' when calling AdminApi->DeleteOAuth2Client");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Ory.Client.Client.ClientUtils.ParameterToString(id)); // path parameter


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/clients/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteOAuth2Client", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete OAuth2 Access Tokens from a Client This endpoint deletes OAuth2 access tokens issued for a client from the database
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId"></param>
        /// <returns></returns>
        public void DeleteOAuth2Token(string clientId)
        {
            DeleteOAuth2TokenWithHttpInfo(clientId);
        }

        /// <summary>
        /// Delete OAuth2 Access Tokens from a Client This endpoint deletes OAuth2 access tokens issued for a client from the database
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Ory.Client.Client.ApiResponse<Object> DeleteOAuth2TokenWithHttpInfo(string clientId)
        {
            // verify the required parameter 'clientId' is set
            if (clientId == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'clientId' when calling AdminApi->DeleteOAuth2Token");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "client_id", clientId));


            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/oauth2/tokens", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteOAuth2Token", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete OAuth2 Access Tokens from a Client This endpoint deletes OAuth2 access tokens issued for a client from the database
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteOAuth2TokenAsync(string clientId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteOAuth2TokenWithHttpInfoAsync(clientId, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete OAuth2 Access Tokens from a Client This endpoint deletes OAuth2 access tokens issued for a client from the database
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<Object>> DeleteOAuth2TokenWithHttpInfoAsync(string clientId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'clientId' is set
            if (clientId == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'clientId' when calling AdminApi->DeleteOAuth2Token");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "client_id", clientId));


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/oauth2/tokens", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteOAuth2Token", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a Trusted OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to delete trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you created the trust relationship.  Once deleted, the associated issuer will no longer be able to perform the JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grant.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the desired grant</param>
        /// <returns></returns>
        public void DeleteTrustedJwtGrantIssuer(string id)
        {
            DeleteTrustedJwtGrantIssuerWithHttpInfo(id);
        }

        /// <summary>
        /// Delete a Trusted OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to delete trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you created the trust relationship.  Once deleted, the associated issuer will no longer be able to perform the JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grant.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the desired grant</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Ory.Client.Client.ApiResponse<Object> DeleteTrustedJwtGrantIssuerWithHttpInfo(string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'id' when calling AdminApi->DeleteTrustedJwtGrantIssuer");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Ory.Client.Client.ClientUtils.ParameterToString(id)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/trust/grants/jwt-bearer/issuers/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteTrustedJwtGrantIssuer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a Trusted OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to delete trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you created the trust relationship.  Once deleted, the associated issuer will no longer be able to perform the JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grant.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the desired grant</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteTrustedJwtGrantIssuerAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteTrustedJwtGrantIssuerWithHttpInfoAsync(id, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a Trusted OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to delete trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you created the trust relationship.  Once deleted, the associated issuer will no longer be able to perform the JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grant.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the desired grant</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<Object>> DeleteTrustedJwtGrantIssuerWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'id' when calling AdminApi->DeleteTrustedJwtGrantIssuer");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Ory.Client.Client.ClientUtils.ParameterToString(id)); // path parameter


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/trust/grants/jwt-bearer/issuers/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteTrustedJwtGrantIssuer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Flush Expired OAuth2 Access Tokens This endpoint flushes expired OAuth2 access tokens from the database. You can set a time after which no tokens will be not be touched, in case you want to keep recent tokens for auditing. Refresh tokens can not be flushed as they are deleted automatically when performing the refresh flow.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientFlushInactiveOAuth2TokensRequest"> (optional)</param>
        /// <returns></returns>
        public void FlushInactiveOAuth2Tokens(ClientFlushInactiveOAuth2TokensRequest clientFlushInactiveOAuth2TokensRequest = default(ClientFlushInactiveOAuth2TokensRequest))
        {
            FlushInactiveOAuth2TokensWithHttpInfo(clientFlushInactiveOAuth2TokensRequest);
        }

        /// <summary>
        /// Flush Expired OAuth2 Access Tokens This endpoint flushes expired OAuth2 access tokens from the database. You can set a time after which no tokens will be not be touched, in case you want to keep recent tokens for auditing. Refresh tokens can not be flushed as they are deleted automatically when performing the refresh flow.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientFlushInactiveOAuth2TokensRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Ory.Client.Client.ApiResponse<Object> FlushInactiveOAuth2TokensWithHttpInfo(ClientFlushInactiveOAuth2TokensRequest clientFlushInactiveOAuth2TokensRequest = default(ClientFlushInactiveOAuth2TokensRequest))
        {
            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = clientFlushInactiveOAuth2TokensRequest;


            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/oauth2/flush", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("FlushInactiveOAuth2Tokens", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Flush Expired OAuth2 Access Tokens This endpoint flushes expired OAuth2 access tokens from the database. You can set a time after which no tokens will be not be touched, in case you want to keep recent tokens for auditing. Refresh tokens can not be flushed as they are deleted automatically when performing the refresh flow.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientFlushInactiveOAuth2TokensRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task FlushInactiveOAuth2TokensAsync(ClientFlushInactiveOAuth2TokensRequest clientFlushInactiveOAuth2TokensRequest = default(ClientFlushInactiveOAuth2TokensRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await FlushInactiveOAuth2TokensWithHttpInfoAsync(clientFlushInactiveOAuth2TokensRequest, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Flush Expired OAuth2 Access Tokens This endpoint flushes expired OAuth2 access tokens from the database. You can set a time after which no tokens will be not be touched, in case you want to keep recent tokens for auditing. Refresh tokens can not be flushed as they are deleted automatically when performing the refresh flow.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientFlushInactiveOAuth2TokensRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<Object>> FlushInactiveOAuth2TokensWithHttpInfoAsync(ClientFlushInactiveOAuth2TokensRequest clientFlushInactiveOAuth2TokensRequest = default(ClientFlushInactiveOAuth2TokensRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = clientFlushInactiveOAuth2TokensRequest;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/oauth2/flush", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("FlushInactiveOAuth2Tokens", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Consent Request Information When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <returns>ClientConsentRequest</returns>
        public ClientConsentRequest GetConsentRequest(string consentChallenge)
        {
            Ory.Client.Client.ApiResponse<ClientConsentRequest> localVarResponse = GetConsentRequestWithHttpInfo(consentChallenge);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Consent Request Information When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <returns>ApiResponse of ClientConsentRequest</returns>
        public Ory.Client.Client.ApiResponse<ClientConsentRequest> GetConsentRequestWithHttpInfo(string consentChallenge)
        {
            // verify the required parameter 'consentChallenge' is set
            if (consentChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'consentChallenge' when calling AdminApi->GetConsentRequest");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "consent_challenge", consentChallenge));


            // make the HTTP request
            var localVarResponse = this.Client.Get<ClientConsentRequest>("/oauth2/auth/requests/consent", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetConsentRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Consent Request Information When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientConsentRequest</returns>
        public async System.Threading.Tasks.Task<ClientConsentRequest> GetConsentRequestAsync(string consentChallenge, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientConsentRequest> localVarResponse = await GetConsentRequestWithHttpInfoAsync(consentChallenge, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Consent Request Information When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientConsentRequest)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientConsentRequest>> GetConsentRequestWithHttpInfoAsync(string consentChallenge, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'consentChallenge' is set
            if (consentChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'consentChallenge' when calling AdminApi->GetConsentRequest");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "consent_challenge", consentChallenge));


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ClientConsentRequest>("/oauth2/auth/requests/consent", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetConsentRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Fetch a JSON Web Key This endpoint returns a singular JSON Web Key, identified by the set and the specific key ID (kid).
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <returns>ClientJSONWebKeySet</returns>
        public ClientJSONWebKeySet GetJsonWebKey(string kid, string set)
        {
            Ory.Client.Client.ApiResponse<ClientJSONWebKeySet> localVarResponse = GetJsonWebKeyWithHttpInfo(kid, set);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Fetch a JSON Web Key This endpoint returns a singular JSON Web Key, identified by the set and the specific key ID (kid).
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <returns>ApiResponse of ClientJSONWebKeySet</returns>
        public Ory.Client.Client.ApiResponse<ClientJSONWebKeySet> GetJsonWebKeyWithHttpInfo(string kid, string set)
        {
            // verify the required parameter 'kid' is set
            if (kid == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'kid' when calling AdminApi->GetJsonWebKey");
            }

            // verify the required parameter 'set' is set
            if (set == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'set' when calling AdminApi->GetJsonWebKey");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("kid", Ory.Client.Client.ClientUtils.ParameterToString(kid)); // path parameter
            localVarRequestOptions.PathParameters.Add("set", Ory.Client.Client.ClientUtils.ParameterToString(set)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<ClientJSONWebKeySet>("/keys/{set}/{kid}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetJsonWebKey", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Fetch a JSON Web Key This endpoint returns a singular JSON Web Key, identified by the set and the specific key ID (kid).
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientJSONWebKeySet</returns>
        public async System.Threading.Tasks.Task<ClientJSONWebKeySet> GetJsonWebKeyAsync(string kid, string set, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientJSONWebKeySet> localVarResponse = await GetJsonWebKeyWithHttpInfoAsync(kid, set, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Fetch a JSON Web Key This endpoint returns a singular JSON Web Key, identified by the set and the specific key ID (kid).
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientJSONWebKeySet)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientJSONWebKeySet>> GetJsonWebKeyWithHttpInfoAsync(string kid, string set, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'kid' is set
            if (kid == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'kid' when calling AdminApi->GetJsonWebKey");
            }

            // verify the required parameter 'set' is set
            if (set == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'set' when calling AdminApi->GetJsonWebKey");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("kid", Ory.Client.Client.ClientUtils.ParameterToString(kid)); // path parameter
            localVarRequestOptions.PathParameters.Add("set", Ory.Client.Client.ClientUtils.ParameterToString(set)); // path parameter


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ClientJSONWebKeySet>("/keys/{set}/{kid}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetJsonWebKey", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve a JSON Web Key Set This endpoint can be used to retrieve JWK Sets stored in ORY Hydra.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <returns>ClientJSONWebKeySet</returns>
        public ClientJSONWebKeySet GetJsonWebKeySet(string set)
        {
            Ory.Client.Client.ApiResponse<ClientJSONWebKeySet> localVarResponse = GetJsonWebKeySetWithHttpInfo(set);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve a JSON Web Key Set This endpoint can be used to retrieve JWK Sets stored in ORY Hydra.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <returns>ApiResponse of ClientJSONWebKeySet</returns>
        public Ory.Client.Client.ApiResponse<ClientJSONWebKeySet> GetJsonWebKeySetWithHttpInfo(string set)
        {
            // verify the required parameter 'set' is set
            if (set == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'set' when calling AdminApi->GetJsonWebKeySet");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("set", Ory.Client.Client.ClientUtils.ParameterToString(set)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<ClientJSONWebKeySet>("/keys/{set}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetJsonWebKeySet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve a JSON Web Key Set This endpoint can be used to retrieve JWK Sets stored in ORY Hydra.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientJSONWebKeySet</returns>
        public async System.Threading.Tasks.Task<ClientJSONWebKeySet> GetJsonWebKeySetAsync(string set, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientJSONWebKeySet> localVarResponse = await GetJsonWebKeySetWithHttpInfoAsync(set, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve a JSON Web Key Set This endpoint can be used to retrieve JWK Sets stored in ORY Hydra.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientJSONWebKeySet)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientJSONWebKeySet>> GetJsonWebKeySetWithHttpInfoAsync(string set, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'set' is set
            if (set == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'set' when calling AdminApi->GetJsonWebKeySet");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("set", Ory.Client.Client.ClientUtils.ParameterToString(set)); // path parameter


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ClientJSONWebKeySet>("/keys/{set}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetJsonWebKeySet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <returns>ClientLoginRequest</returns>
        public ClientLoginRequest GetLoginRequest(string loginChallenge)
        {
            Ory.Client.Client.ApiResponse<ClientLoginRequest> localVarResponse = GetLoginRequestWithHttpInfo(loginChallenge);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <returns>ApiResponse of ClientLoginRequest</returns>
        public Ory.Client.Client.ApiResponse<ClientLoginRequest> GetLoginRequestWithHttpInfo(string loginChallenge)
        {
            // verify the required parameter 'loginChallenge' is set
            if (loginChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'loginChallenge' when calling AdminApi->GetLoginRequest");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "login_challenge", loginChallenge));


            // make the HTTP request
            var localVarResponse = this.Client.Get<ClientLoginRequest>("/oauth2/auth/requests/login", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLoginRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientLoginRequest</returns>
        public async System.Threading.Tasks.Task<ClientLoginRequest> GetLoginRequestAsync(string loginChallenge, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientLoginRequest> localVarResponse = await GetLoginRequestWithHttpInfoAsync(loginChallenge, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientLoginRequest)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientLoginRequest>> GetLoginRequestWithHttpInfoAsync(string loginChallenge, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'loginChallenge' is set
            if (loginChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'loginChallenge' when calling AdminApi->GetLoginRequest");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "login_challenge", loginChallenge));


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ClientLoginRequest>("/oauth2/auth/requests/login", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLoginRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a Logout Request Use this endpoint to fetch a logout request.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <returns>ClientLogoutRequest</returns>
        public ClientLogoutRequest GetLogoutRequest(string logoutChallenge)
        {
            Ory.Client.Client.ApiResponse<ClientLogoutRequest> localVarResponse = GetLogoutRequestWithHttpInfo(logoutChallenge);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a Logout Request Use this endpoint to fetch a logout request.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <returns>ApiResponse of ClientLogoutRequest</returns>
        public Ory.Client.Client.ApiResponse<ClientLogoutRequest> GetLogoutRequestWithHttpInfo(string logoutChallenge)
        {
            // verify the required parameter 'logoutChallenge' is set
            if (logoutChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'logoutChallenge' when calling AdminApi->GetLogoutRequest");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "logout_challenge", logoutChallenge));


            // make the HTTP request
            var localVarResponse = this.Client.Get<ClientLogoutRequest>("/oauth2/auth/requests/logout", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLogoutRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a Logout Request Use this endpoint to fetch a logout request.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientLogoutRequest</returns>
        public async System.Threading.Tasks.Task<ClientLogoutRequest> GetLogoutRequestAsync(string logoutChallenge, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientLogoutRequest> localVarResponse = await GetLogoutRequestWithHttpInfoAsync(logoutChallenge, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a Logout Request Use this endpoint to fetch a logout request.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientLogoutRequest)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientLogoutRequest>> GetLogoutRequestWithHttpInfoAsync(string logoutChallenge, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'logoutChallenge' is set
            if (logoutChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'logoutChallenge' when calling AdminApi->GetLogoutRequest");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "logout_challenge", logoutChallenge));


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ClientLogoutRequest>("/oauth2/auth/requests/logout", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLogoutRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get an OAuth 2.0 Client Get an OAuth 2.0 client by its ID. This endpoint never returns the client secret.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <returns>ClientOAuth2Client</returns>
        public ClientOAuth2Client GetOAuth2Client(string id)
        {
            Ory.Client.Client.ApiResponse<ClientOAuth2Client> localVarResponse = GetOAuth2ClientWithHttpInfo(id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get an OAuth 2.0 Client Get an OAuth 2.0 client by its ID. This endpoint never returns the client secret.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <returns>ApiResponse of ClientOAuth2Client</returns>
        public Ory.Client.Client.ApiResponse<ClientOAuth2Client> GetOAuth2ClientWithHttpInfo(string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'id' when calling AdminApi->GetOAuth2Client");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Ory.Client.Client.ClientUtils.ParameterToString(id)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<ClientOAuth2Client>("/clients/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetOAuth2Client", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get an OAuth 2.0 Client Get an OAuth 2.0 client by its ID. This endpoint never returns the client secret.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientOAuth2Client</returns>
        public async System.Threading.Tasks.Task<ClientOAuth2Client> GetOAuth2ClientAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientOAuth2Client> localVarResponse = await GetOAuth2ClientWithHttpInfoAsync(id, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get an OAuth 2.0 Client Get an OAuth 2.0 client by its ID. This endpoint never returns the client secret.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientOAuth2Client)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientOAuth2Client>> GetOAuth2ClientWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'id' when calling AdminApi->GetOAuth2Client");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Ory.Client.Client.ClientUtils.ParameterToString(id)); // path parameter


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ClientOAuth2Client>("/clients/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetOAuth2Client", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a Trusted OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to get a trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you created the trust relationship.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the desired grant</param>
        /// <returns>ClientTrustedJwtGrantIssuer</returns>
        public ClientTrustedJwtGrantIssuer GetTrustedJwtGrantIssuer(string id)
        {
            Ory.Client.Client.ApiResponse<ClientTrustedJwtGrantIssuer> localVarResponse = GetTrustedJwtGrantIssuerWithHttpInfo(id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a Trusted OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to get a trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you created the trust relationship.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the desired grant</param>
        /// <returns>ApiResponse of ClientTrustedJwtGrantIssuer</returns>
        public Ory.Client.Client.ApiResponse<ClientTrustedJwtGrantIssuer> GetTrustedJwtGrantIssuerWithHttpInfo(string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'id' when calling AdminApi->GetTrustedJwtGrantIssuer");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Ory.Client.Client.ClientUtils.ParameterToString(id)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<ClientTrustedJwtGrantIssuer>("/trust/grants/jwt-bearer/issuers/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTrustedJwtGrantIssuer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a Trusted OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to get a trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you created the trust relationship.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the desired grant</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientTrustedJwtGrantIssuer</returns>
        public async System.Threading.Tasks.Task<ClientTrustedJwtGrantIssuer> GetTrustedJwtGrantIssuerAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientTrustedJwtGrantIssuer> localVarResponse = await GetTrustedJwtGrantIssuerWithHttpInfoAsync(id, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a Trusted OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to get a trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you created the trust relationship.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the desired grant</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientTrustedJwtGrantIssuer)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientTrustedJwtGrantIssuer>> GetTrustedJwtGrantIssuerWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'id' when calling AdminApi->GetTrustedJwtGrantIssuer");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Ory.Client.Client.ClientUtils.ParameterToString(id)); // path parameter


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ClientTrustedJwtGrantIssuer>("/trust/grants/jwt-bearer/issuers/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTrustedJwtGrantIssuer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Introspect OAuth2 Tokens The introspection endpoint allows to check if a token (both refresh and access) is active or not. An active token is neither expired nor revoked. If a token is active, additional information on the token will be included. You can set additional data for a token by setting &#x60;accessTokenExtra&#x60; during the consent flow.  For more information [read this blog post](https://www.oauth.com/oauth2-servers/token-introspection-endpoint/).
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The string value of the token. For access tokens, this is the \\\&quot;access_token\\\&quot; value returned from the token endpoint defined in OAuth 2.0. For refresh tokens, this is the \\\&quot;refresh_token\\\&quot; value returned.</param>
        /// <param name="scope">An optional, space separated list of required scopes. If the access token was not granted one of the scopes, the result of active will be false. (optional)</param>
        /// <returns>ClientOAuth2TokenIntrospection</returns>
        public ClientOAuth2TokenIntrospection IntrospectOAuth2Token(string token, string scope = default(string))
        {
            Ory.Client.Client.ApiResponse<ClientOAuth2TokenIntrospection> localVarResponse = IntrospectOAuth2TokenWithHttpInfo(token, scope);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Introspect OAuth2 Tokens The introspection endpoint allows to check if a token (both refresh and access) is active or not. An active token is neither expired nor revoked. If a token is active, additional information on the token will be included. You can set additional data for a token by setting &#x60;accessTokenExtra&#x60; during the consent flow.  For more information [read this blog post](https://www.oauth.com/oauth2-servers/token-introspection-endpoint/).
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The string value of the token. For access tokens, this is the \\\&quot;access_token\\\&quot; value returned from the token endpoint defined in OAuth 2.0. For refresh tokens, this is the \\\&quot;refresh_token\\\&quot; value returned.</param>
        /// <param name="scope">An optional, space separated list of required scopes. If the access token was not granted one of the scopes, the result of active will be false. (optional)</param>
        /// <returns>ApiResponse of ClientOAuth2TokenIntrospection</returns>
        public Ory.Client.Client.ApiResponse<ClientOAuth2TokenIntrospection> IntrospectOAuth2TokenWithHttpInfo(string token, string scope = default(string))
        {
            // verify the required parameter 'token' is set
            if (token == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'token' when calling AdminApi->IntrospectOAuth2Token");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (scope != null)
            {
                localVarRequestOptions.FormParameters.Add("scope", Ory.Client.Client.ClientUtils.ParameterToString(scope)); // form parameter
            }
            localVarRequestOptions.FormParameters.Add("token", Ory.Client.Client.ClientUtils.ParameterToString(token)); // form parameter


            // make the HTTP request
            var localVarResponse = this.Client.Post<ClientOAuth2TokenIntrospection>("/oauth2/introspect", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IntrospectOAuth2Token", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Introspect OAuth2 Tokens The introspection endpoint allows to check if a token (both refresh and access) is active or not. An active token is neither expired nor revoked. If a token is active, additional information on the token will be included. You can set additional data for a token by setting &#x60;accessTokenExtra&#x60; during the consent flow.  For more information [read this blog post](https://www.oauth.com/oauth2-servers/token-introspection-endpoint/).
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The string value of the token. For access tokens, this is the \\\&quot;access_token\\\&quot; value returned from the token endpoint defined in OAuth 2.0. For refresh tokens, this is the \\\&quot;refresh_token\\\&quot; value returned.</param>
        /// <param name="scope">An optional, space separated list of required scopes. If the access token was not granted one of the scopes, the result of active will be false. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientOAuth2TokenIntrospection</returns>
        public async System.Threading.Tasks.Task<ClientOAuth2TokenIntrospection> IntrospectOAuth2TokenAsync(string token, string scope = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientOAuth2TokenIntrospection> localVarResponse = await IntrospectOAuth2TokenWithHttpInfoAsync(token, scope, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Introspect OAuth2 Tokens The introspection endpoint allows to check if a token (both refresh and access) is active or not. An active token is neither expired nor revoked. If a token is active, additional information on the token will be included. You can set additional data for a token by setting &#x60;accessTokenExtra&#x60; during the consent flow.  For more information [read this blog post](https://www.oauth.com/oauth2-servers/token-introspection-endpoint/).
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The string value of the token. For access tokens, this is the \\\&quot;access_token\\\&quot; value returned from the token endpoint defined in OAuth 2.0. For refresh tokens, this is the \\\&quot;refresh_token\\\&quot; value returned.</param>
        /// <param name="scope">An optional, space separated list of required scopes. If the access token was not granted one of the scopes, the result of active will be false. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientOAuth2TokenIntrospection)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientOAuth2TokenIntrospection>> IntrospectOAuth2TokenWithHttpInfoAsync(string token, string scope = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'token' is set
            if (token == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'token' when calling AdminApi->IntrospectOAuth2Token");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (scope != null)
            {
                localVarRequestOptions.FormParameters.Add("scope", Ory.Client.Client.ClientUtils.ParameterToString(scope)); // form parameter
            }
            localVarRequestOptions.FormParameters.Add("token", Ory.Client.Client.ClientUtils.ParameterToString(token)); // form parameter


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ClientOAuth2TokenIntrospection>("/oauth2/introspect", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IntrospectOAuth2Token", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List OAuth 2.0 Clients This endpoint lists all clients in the database, and never returns client secrets. As a default it lists the first 100 clients. The &#x60;limit&#x60; parameter can be used to retrieve more clients, but it has an upper bound at 500 objects. Pagination should be used to retrieve more than 500 objects.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  The \&quot;Link\&quot; header is also included in successful responses, which contains one or more links for pagination, formatted like so: &#39;&lt;https://hydra-url/admin/clients?limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;; rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;, &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will be separated by a comma.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">The maximum amount of clients to returned, upper bound is 500 clients. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="clientName">The name of the clients to filter by. (optional)</param>
        /// <param name="owner">The owner of the clients to filter by. (optional)</param>
        /// <returns>List&lt;ClientOAuth2Client&gt;</returns>
        public List<ClientOAuth2Client> ListOAuth2Clients(long? limit = default(long?), long? offset = default(long?), string clientName = default(string), string owner = default(string))
        {
            Ory.Client.Client.ApiResponse<List<ClientOAuth2Client>> localVarResponse = ListOAuth2ClientsWithHttpInfo(limit, offset, clientName, owner);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List OAuth 2.0 Clients This endpoint lists all clients in the database, and never returns client secrets. As a default it lists the first 100 clients. The &#x60;limit&#x60; parameter can be used to retrieve more clients, but it has an upper bound at 500 objects. Pagination should be used to retrieve more than 500 objects.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  The \&quot;Link\&quot; header is also included in successful responses, which contains one or more links for pagination, formatted like so: &#39;&lt;https://hydra-url/admin/clients?limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;; rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;, &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will be separated by a comma.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">The maximum amount of clients to returned, upper bound is 500 clients. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="clientName">The name of the clients to filter by. (optional)</param>
        /// <param name="owner">The owner of the clients to filter by. (optional)</param>
        /// <returns>ApiResponse of List&lt;ClientOAuth2Client&gt;</returns>
        public Ory.Client.Client.ApiResponse<List<ClientOAuth2Client>> ListOAuth2ClientsWithHttpInfo(long? limit = default(long?), long? offset = default(long?), string clientName = default(string), string owner = default(string))
        {
            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (clientName != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "client_name", clientName));
            }
            if (owner != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "owner", owner));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<ClientOAuth2Client>>("/clients", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListOAuth2Clients", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List OAuth 2.0 Clients This endpoint lists all clients in the database, and never returns client secrets. As a default it lists the first 100 clients. The &#x60;limit&#x60; parameter can be used to retrieve more clients, but it has an upper bound at 500 objects. Pagination should be used to retrieve more than 500 objects.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  The \&quot;Link\&quot; header is also included in successful responses, which contains one or more links for pagination, formatted like so: &#39;&lt;https://hydra-url/admin/clients?limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;; rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;, &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will be separated by a comma.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">The maximum amount of clients to returned, upper bound is 500 clients. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="clientName">The name of the clients to filter by. (optional)</param>
        /// <param name="owner">The owner of the clients to filter by. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ClientOAuth2Client&gt;</returns>
        public async System.Threading.Tasks.Task<List<ClientOAuth2Client>> ListOAuth2ClientsAsync(long? limit = default(long?), long? offset = default(long?), string clientName = default(string), string owner = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<List<ClientOAuth2Client>> localVarResponse = await ListOAuth2ClientsWithHttpInfoAsync(limit, offset, clientName, owner, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List OAuth 2.0 Clients This endpoint lists all clients in the database, and never returns client secrets. As a default it lists the first 100 clients. The &#x60;limit&#x60; parameter can be used to retrieve more clients, but it has an upper bound at 500 objects. Pagination should be used to retrieve more than 500 objects.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  The \&quot;Link\&quot; header is also included in successful responses, which contains one or more links for pagination, formatted like so: &#39;&lt;https://hydra-url/admin/clients?limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;; rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;, &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will be separated by a comma.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">The maximum amount of clients to returned, upper bound is 500 clients. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="clientName">The name of the clients to filter by. (optional)</param>
        /// <param name="owner">The owner of the clients to filter by. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ClientOAuth2Client&gt;)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<List<ClientOAuth2Client>>> ListOAuth2ClientsWithHttpInfoAsync(long? limit = default(long?), long? offset = default(long?), string clientName = default(string), string owner = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (clientName != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "client_name", clientName));
            }
            if (owner != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "owner", owner));
            }


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<ClientOAuth2Client>>("/clients", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListOAuth2Clients", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Lists All Consent Sessions of a Subject This endpoint lists all subject&#39;s granted consent sessions, including client and granted scope. If the subject is unknown or has not granted any consent sessions yet, the endpoint returns an empty JSON array with status code 200 OK.   The \&quot;Link\&quot; header is also included in successful responses, which contains one or more links for pagination, formatted like so: &#39;&lt;https://hydra-url/admin/oauth2/auth/sessions/consent?subject&#x3D;{user}&amp;limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;; rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;, &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will be separated by a comma.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject"></param>
        /// <param name="limit">The maximum amount of consent sessions to be returned, upper bound is 500 sessions. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <returns>List&lt;ClientPreviousConsentSession&gt;</returns>
        public List<ClientPreviousConsentSession> ListSubjectConsentSessions(string subject, long? limit = default(long?), long? offset = default(long?))
        {
            Ory.Client.Client.ApiResponse<List<ClientPreviousConsentSession>> localVarResponse = ListSubjectConsentSessionsWithHttpInfo(subject, limit, offset);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Lists All Consent Sessions of a Subject This endpoint lists all subject&#39;s granted consent sessions, including client and granted scope. If the subject is unknown or has not granted any consent sessions yet, the endpoint returns an empty JSON array with status code 200 OK.   The \&quot;Link\&quot; header is also included in successful responses, which contains one or more links for pagination, formatted like so: &#39;&lt;https://hydra-url/admin/oauth2/auth/sessions/consent?subject&#x3D;{user}&amp;limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;; rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;, &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will be separated by a comma.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject"></param>
        /// <param name="limit">The maximum amount of consent sessions to be returned, upper bound is 500 sessions. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <returns>ApiResponse of List&lt;ClientPreviousConsentSession&gt;</returns>
        public Ory.Client.Client.ApiResponse<List<ClientPreviousConsentSession>> ListSubjectConsentSessionsWithHttpInfo(string subject, long? limit = default(long?), long? offset = default(long?))
        {
            // verify the required parameter 'subject' is set
            if (subject == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'subject' when calling AdminApi->ListSubjectConsentSessions");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "subject", subject));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<ClientPreviousConsentSession>>("/oauth2/auth/sessions/consent", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListSubjectConsentSessions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Lists All Consent Sessions of a Subject This endpoint lists all subject&#39;s granted consent sessions, including client and granted scope. If the subject is unknown or has not granted any consent sessions yet, the endpoint returns an empty JSON array with status code 200 OK.   The \&quot;Link\&quot; header is also included in successful responses, which contains one or more links for pagination, formatted like so: &#39;&lt;https://hydra-url/admin/oauth2/auth/sessions/consent?subject&#x3D;{user}&amp;limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;; rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;, &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will be separated by a comma.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject"></param>
        /// <param name="limit">The maximum amount of consent sessions to be returned, upper bound is 500 sessions. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ClientPreviousConsentSession&gt;</returns>
        public async System.Threading.Tasks.Task<List<ClientPreviousConsentSession>> ListSubjectConsentSessionsAsync(string subject, long? limit = default(long?), long? offset = default(long?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<List<ClientPreviousConsentSession>> localVarResponse = await ListSubjectConsentSessionsWithHttpInfoAsync(subject, limit, offset, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Lists All Consent Sessions of a Subject This endpoint lists all subject&#39;s granted consent sessions, including client and granted scope. If the subject is unknown or has not granted any consent sessions yet, the endpoint returns an empty JSON array with status code 200 OK.   The \&quot;Link\&quot; header is also included in successful responses, which contains one or more links for pagination, formatted like so: &#39;&lt;https://hydra-url/admin/oauth2/auth/sessions/consent?subject&#x3D;{user}&amp;limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;; rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;, &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will be separated by a comma.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject"></param>
        /// <param name="limit">The maximum amount of consent sessions to be returned, upper bound is 500 sessions. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ClientPreviousConsentSession&gt;)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<List<ClientPreviousConsentSession>>> ListSubjectConsentSessionsWithHttpInfoAsync(string subject, long? limit = default(long?), long? offset = default(long?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'subject' is set
            if (subject == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'subject' when calling AdminApi->ListSubjectConsentSessions");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "subject", subject));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<ClientPreviousConsentSession>>("/oauth2/auth/sessions/consent", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListSubjectConsentSessions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Trusted OAuth2 JWT Bearer Grant Type Issuers Use this endpoint to list all trusted JWT Bearer Grant Type Issuers.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issuer">If optional \&quot;issuer\&quot; is supplied, only jwt-bearer grants with this issuer will be returned. (optional)</param>
        /// <param name="limit">The maximum amount of policies returned, upper bound is 500 policies (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <returns>List&lt;ClientTrustedJwtGrantIssuer&gt;</returns>
        public List<ClientTrustedJwtGrantIssuer> ListTrustedJwtGrantIssuers(string issuer = default(string), long? limit = default(long?), long? offset = default(long?))
        {
            Ory.Client.Client.ApiResponse<List<ClientTrustedJwtGrantIssuer>> localVarResponse = ListTrustedJwtGrantIssuersWithHttpInfo(issuer, limit, offset);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Trusted OAuth2 JWT Bearer Grant Type Issuers Use this endpoint to list all trusted JWT Bearer Grant Type Issuers.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issuer">If optional \&quot;issuer\&quot; is supplied, only jwt-bearer grants with this issuer will be returned. (optional)</param>
        /// <param name="limit">The maximum amount of policies returned, upper bound is 500 policies (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <returns>ApiResponse of List&lt;ClientTrustedJwtGrantIssuer&gt;</returns>
        public Ory.Client.Client.ApiResponse<List<ClientTrustedJwtGrantIssuer>> ListTrustedJwtGrantIssuersWithHttpInfo(string issuer = default(string), long? limit = default(long?), long? offset = default(long?))
        {
            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (issuer != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "issuer", issuer));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<ClientTrustedJwtGrantIssuer>>("/trust/grants/jwt-bearer/issuers", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListTrustedJwtGrantIssuers", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Trusted OAuth2 JWT Bearer Grant Type Issuers Use this endpoint to list all trusted JWT Bearer Grant Type Issuers.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issuer">If optional \&quot;issuer\&quot; is supplied, only jwt-bearer grants with this issuer will be returned. (optional)</param>
        /// <param name="limit">The maximum amount of policies returned, upper bound is 500 policies (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ClientTrustedJwtGrantIssuer&gt;</returns>
        public async System.Threading.Tasks.Task<List<ClientTrustedJwtGrantIssuer>> ListTrustedJwtGrantIssuersAsync(string issuer = default(string), long? limit = default(long?), long? offset = default(long?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<List<ClientTrustedJwtGrantIssuer>> localVarResponse = await ListTrustedJwtGrantIssuersWithHttpInfoAsync(issuer, limit, offset, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Trusted OAuth2 JWT Bearer Grant Type Issuers Use this endpoint to list all trusted JWT Bearer Grant Type Issuers.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issuer">If optional \&quot;issuer\&quot; is supplied, only jwt-bearer grants with this issuer will be returned. (optional)</param>
        /// <param name="limit">The maximum amount of policies returned, upper bound is 500 policies (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ClientTrustedJwtGrantIssuer&gt;)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<List<ClientTrustedJwtGrantIssuer>>> ListTrustedJwtGrantIssuersWithHttpInfoAsync(string issuer = default(string), long? limit = default(long?), long? offset = default(long?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (issuer != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "issuer", issuer));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<ClientTrustedJwtGrantIssuer>>("/trust/grants/jwt-bearer/issuers", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListTrustedJwtGrantIssuers", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Patch an OAuth 2.0 Client Patch an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="clientPatchDocument"></param>
        /// <returns>ClientOAuth2Client</returns>
        public ClientOAuth2Client PatchOAuth2Client(string id, List<ClientPatchDocument> clientPatchDocument)
        {
            Ory.Client.Client.ApiResponse<ClientOAuth2Client> localVarResponse = PatchOAuth2ClientWithHttpInfo(id, clientPatchDocument);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Patch an OAuth 2.0 Client Patch an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="clientPatchDocument"></param>
        /// <returns>ApiResponse of ClientOAuth2Client</returns>
        public Ory.Client.Client.ApiResponse<ClientOAuth2Client> PatchOAuth2ClientWithHttpInfo(string id, List<ClientPatchDocument> clientPatchDocument)
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'id' when calling AdminApi->PatchOAuth2Client");
            }

            // verify the required parameter 'clientPatchDocument' is set
            if (clientPatchDocument == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'clientPatchDocument' when calling AdminApi->PatchOAuth2Client");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Ory.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = clientPatchDocument;


            // make the HTTP request
            var localVarResponse = this.Client.Patch<ClientOAuth2Client>("/clients/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("PatchOAuth2Client", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Patch an OAuth 2.0 Client Patch an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="clientPatchDocument"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientOAuth2Client</returns>
        public async System.Threading.Tasks.Task<ClientOAuth2Client> PatchOAuth2ClientAsync(string id, List<ClientPatchDocument> clientPatchDocument, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientOAuth2Client> localVarResponse = await PatchOAuth2ClientWithHttpInfoAsync(id, clientPatchDocument, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Patch an OAuth 2.0 Client Patch an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="clientPatchDocument"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientOAuth2Client)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientOAuth2Client>> PatchOAuth2ClientWithHttpInfoAsync(string id, List<ClientPatchDocument> clientPatchDocument, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'id' when calling AdminApi->PatchOAuth2Client");
            }

            // verify the required parameter 'clientPatchDocument' is set
            if (clientPatchDocument == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'clientPatchDocument' when calling AdminApi->PatchOAuth2Client");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Ory.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = clientPatchDocument;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PatchAsync<ClientOAuth2Client>("/clients/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("PatchOAuth2Client", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Reject a Consent Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY Hydra that the subject has not authorized the OAuth 2.0 client to access resources on his/her behalf. The consent provider must include a reason why the consent was not granted.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <returns>ClientCompletedRequest</returns>
        public ClientCompletedRequest RejectConsentRequest(string consentChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest))
        {
            Ory.Client.Client.ApiResponse<ClientCompletedRequest> localVarResponse = RejectConsentRequestWithHttpInfo(consentChallenge, clientRejectRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Reject a Consent Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY Hydra that the subject has not authorized the OAuth 2.0 client to access resources on his/her behalf. The consent provider must include a reason why the consent was not granted.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <returns>ApiResponse of ClientCompletedRequest</returns>
        public Ory.Client.Client.ApiResponse<ClientCompletedRequest> RejectConsentRequestWithHttpInfo(string consentChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest))
        {
            // verify the required parameter 'consentChallenge' is set
            if (consentChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'consentChallenge' when calling AdminApi->RejectConsentRequest");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "consent_challenge", consentChallenge));
            localVarRequestOptions.Data = clientRejectRequest;


            // make the HTTP request
            var localVarResponse = this.Client.Put<ClientCompletedRequest>("/oauth2/auth/requests/consent/reject", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RejectConsentRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Reject a Consent Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY Hydra that the subject has not authorized the OAuth 2.0 client to access resources on his/her behalf. The consent provider must include a reason why the consent was not granted.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientCompletedRequest</returns>
        public async System.Threading.Tasks.Task<ClientCompletedRequest> RejectConsentRequestAsync(string consentChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientCompletedRequest> localVarResponse = await RejectConsentRequestWithHttpInfoAsync(consentChallenge, clientRejectRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Reject a Consent Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY Hydra that the subject has not authorized the OAuth 2.0 client to access resources on his/her behalf. The consent provider must include a reason why the consent was not granted.  The response contains a redirect URL which the consent provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="consentChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientCompletedRequest)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientCompletedRequest>> RejectConsentRequestWithHttpInfoAsync(string consentChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'consentChallenge' is set
            if (consentChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'consentChallenge' when calling AdminApi->RejectConsentRequest");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "consent_challenge", consentChallenge));
            localVarRequestOptions.Data = clientRejectRequest;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<ClientCompletedRequest>("/oauth2/auth/requests/consent/reject", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RejectConsentRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Reject a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY Hydra that the subject has not authenticated and includes a reason why the authentication was be denied.  The response contains a redirect URL which the login provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <returns>ClientCompletedRequest</returns>
        public ClientCompletedRequest RejectLoginRequest(string loginChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest))
        {
            Ory.Client.Client.ApiResponse<ClientCompletedRequest> localVarResponse = RejectLoginRequestWithHttpInfo(loginChallenge, clientRejectRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Reject a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY Hydra that the subject has not authenticated and includes a reason why the authentication was be denied.  The response contains a redirect URL which the login provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <returns>ApiResponse of ClientCompletedRequest</returns>
        public Ory.Client.Client.ApiResponse<ClientCompletedRequest> RejectLoginRequestWithHttpInfo(string loginChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest))
        {
            // verify the required parameter 'loginChallenge' is set
            if (loginChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'loginChallenge' when calling AdminApi->RejectLoginRequest");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "login_challenge", loginChallenge));
            localVarRequestOptions.Data = clientRejectRequest;


            // make the HTTP request
            var localVarResponse = this.Client.Put<ClientCompletedRequest>("/oauth2/auth/requests/login/reject", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RejectLoginRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Reject a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY Hydra that the subject has not authenticated and includes a reason why the authentication was be denied.  The response contains a redirect URL which the login provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientCompletedRequest</returns>
        public async System.Threading.Tasks.Task<ClientCompletedRequest> RejectLoginRequestAsync(string loginChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientCompletedRequest> localVarResponse = await RejectLoginRequestWithHttpInfoAsync(loginChallenge, clientRejectRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Reject a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY Hydra that the subject has not authenticated and includes a reason why the authentication was be denied.  The response contains a redirect URL which the login provider should redirect the user-agent to.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="loginChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientCompletedRequest)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientCompletedRequest>> RejectLoginRequestWithHttpInfoAsync(string loginChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'loginChallenge' is set
            if (loginChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'loginChallenge' when calling AdminApi->RejectLoginRequest");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "login_challenge", loginChallenge));
            localVarRequestOptions.Data = clientRejectRequest;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<ClientCompletedRequest>("/oauth2/auth/requests/login/reject", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RejectLoginRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Reject a Logout Request When a user or an application requests ORY Hydra to log out a user, this endpoint is used to deny that logout request. No body is required.  The response is empty as the logout provider has to chose what action to perform next.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <returns></returns>
        public void RejectLogoutRequest(string logoutChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest))
        {
            RejectLogoutRequestWithHttpInfo(logoutChallenge, clientRejectRequest);
        }

        /// <summary>
        /// Reject a Logout Request When a user or an application requests ORY Hydra to log out a user, this endpoint is used to deny that logout request. No body is required.  The response is empty as the logout provider has to chose what action to perform next.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Ory.Client.Client.ApiResponse<Object> RejectLogoutRequestWithHttpInfo(string logoutChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest))
        {
            // verify the required parameter 'logoutChallenge' is set
            if (logoutChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'logoutChallenge' when calling AdminApi->RejectLogoutRequest");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "logout_challenge", logoutChallenge));
            localVarRequestOptions.Data = clientRejectRequest;


            // make the HTTP request
            var localVarResponse = this.Client.Put<Object>("/oauth2/auth/requests/logout/reject", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RejectLogoutRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Reject a Logout Request When a user or an application requests ORY Hydra to log out a user, this endpoint is used to deny that logout request. No body is required.  The response is empty as the logout provider has to chose what action to perform next.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RejectLogoutRequestAsync(string logoutChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RejectLogoutRequestWithHttpInfoAsync(logoutChallenge, clientRejectRequest, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Reject a Logout Request When a user or an application requests ORY Hydra to log out a user, this endpoint is used to deny that logout request. No body is required.  The response is empty as the logout provider has to chose what action to perform next.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="logoutChallenge"></param>
        /// <param name="clientRejectRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<Object>> RejectLogoutRequestWithHttpInfoAsync(string logoutChallenge, ClientRejectRequest clientRejectRequest = default(ClientRejectRequest), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'logoutChallenge' is set
            if (logoutChallenge == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'logoutChallenge' when calling AdminApi->RejectLogoutRequest");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "logout_challenge", logoutChallenge));
            localVarRequestOptions.Data = clientRejectRequest;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<Object>("/oauth2/auth/requests/logout/reject", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RejectLogoutRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Invalidates All Login Sessions of a Certain User Invalidates a Subject&#39;s Authentication Session This endpoint invalidates a subject&#39;s authentication session. After revoking the authentication session, the subject has to re-authenticate at ORY Hydra. This endpoint does not invalidate any tokens and does not work with OpenID Connect Front- or Back-channel logout.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject"></param>
        /// <returns></returns>
        public void RevokeAuthenticationSession(string subject)
        {
            RevokeAuthenticationSessionWithHttpInfo(subject);
        }

        /// <summary>
        /// Invalidates All Login Sessions of a Certain User Invalidates a Subject&#39;s Authentication Session This endpoint invalidates a subject&#39;s authentication session. After revoking the authentication session, the subject has to re-authenticate at ORY Hydra. This endpoint does not invalidate any tokens and does not work with OpenID Connect Front- or Back-channel logout.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Ory.Client.Client.ApiResponse<Object> RevokeAuthenticationSessionWithHttpInfo(string subject)
        {
            // verify the required parameter 'subject' is set
            if (subject == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'subject' when calling AdminApi->RevokeAuthenticationSession");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "subject", subject));


            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/oauth2/auth/sessions/login", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RevokeAuthenticationSession", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Invalidates All Login Sessions of a Certain User Invalidates a Subject&#39;s Authentication Session This endpoint invalidates a subject&#39;s authentication session. After revoking the authentication session, the subject has to re-authenticate at ORY Hydra. This endpoint does not invalidate any tokens and does not work with OpenID Connect Front- or Back-channel logout.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RevokeAuthenticationSessionAsync(string subject, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RevokeAuthenticationSessionWithHttpInfoAsync(subject, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Invalidates All Login Sessions of a Certain User Invalidates a Subject&#39;s Authentication Session This endpoint invalidates a subject&#39;s authentication session. After revoking the authentication session, the subject has to re-authenticate at ORY Hydra. This endpoint does not invalidate any tokens and does not work with OpenID Connect Front- or Back-channel logout.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<Object>> RevokeAuthenticationSessionWithHttpInfoAsync(string subject, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'subject' is set
            if (subject == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'subject' when calling AdminApi->RevokeAuthenticationSession");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "subject", subject));


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/oauth2/auth/sessions/login", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RevokeAuthenticationSession", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Revokes Consent Sessions of a Subject for a Specific OAuth 2.0 Client This endpoint revokes a subject&#39;s granted consent sessions for a specific OAuth 2.0 Client and invalidates all associated OAuth 2.0 Access Tokens.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject">The subject (Subject) who&#39;s consent sessions should be deleted.</param>
        /// <param name="_client">If set, deletes only those consent sessions by the Subject that have been granted to the specified OAuth 2.0 Client ID (optional)</param>
        /// <param name="all">If set to &#x60;?all&#x3D;true&#x60;, deletes all consent sessions by the Subject that have been granted. (optional)</param>
        /// <returns></returns>
        public void RevokeConsentSessions(string subject, string _client = default(string), bool? all = default(bool?))
        {
            RevokeConsentSessionsWithHttpInfo(subject, _client, all);
        }

        /// <summary>
        /// Revokes Consent Sessions of a Subject for a Specific OAuth 2.0 Client This endpoint revokes a subject&#39;s granted consent sessions for a specific OAuth 2.0 Client and invalidates all associated OAuth 2.0 Access Tokens.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject">The subject (Subject) who&#39;s consent sessions should be deleted.</param>
        /// <param name="_client">If set, deletes only those consent sessions by the Subject that have been granted to the specified OAuth 2.0 Client ID (optional)</param>
        /// <param name="all">If set to &#x60;?all&#x3D;true&#x60;, deletes all consent sessions by the Subject that have been granted. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Ory.Client.Client.ApiResponse<Object> RevokeConsentSessionsWithHttpInfo(string subject, string _client = default(string), bool? all = default(bool?))
        {
            // verify the required parameter 'subject' is set
            if (subject == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'subject' when calling AdminApi->RevokeConsentSessions");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "subject", subject));
            if (_client != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "client", _client));
            }
            if (all != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "all", all));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/oauth2/auth/sessions/consent", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RevokeConsentSessions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Revokes Consent Sessions of a Subject for a Specific OAuth 2.0 Client This endpoint revokes a subject&#39;s granted consent sessions for a specific OAuth 2.0 Client and invalidates all associated OAuth 2.0 Access Tokens.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject">The subject (Subject) who&#39;s consent sessions should be deleted.</param>
        /// <param name="_client">If set, deletes only those consent sessions by the Subject that have been granted to the specified OAuth 2.0 Client ID (optional)</param>
        /// <param name="all">If set to &#x60;?all&#x3D;true&#x60;, deletes all consent sessions by the Subject that have been granted. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RevokeConsentSessionsAsync(string subject, string _client = default(string), bool? all = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RevokeConsentSessionsWithHttpInfoAsync(subject, _client, all, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Revokes Consent Sessions of a Subject for a Specific OAuth 2.0 Client This endpoint revokes a subject&#39;s granted consent sessions for a specific OAuth 2.0 Client and invalidates all associated OAuth 2.0 Access Tokens.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subject">The subject (Subject) who&#39;s consent sessions should be deleted.</param>
        /// <param name="_client">If set, deletes only those consent sessions by the Subject that have been granted to the specified OAuth 2.0 Client ID (optional)</param>
        /// <param name="all">If set to &#x60;?all&#x3D;true&#x60;, deletes all consent sessions by the Subject that have been granted. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<Object>> RevokeConsentSessionsWithHttpInfoAsync(string subject, string _client = default(string), bool? all = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'subject' is set
            if (subject == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'subject' when calling AdminApi->RevokeConsentSessions");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "subject", subject));
            if (_client != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "client", _client));
            }
            if (all != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Client.Client.ClientUtils.ParameterToMultiMap("", "all", all));
            }


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/oauth2/auth/sessions/consent", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RevokeConsentSessions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Trust an OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to establish a trust relationship for a JWT issuer to perform JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523).
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientTrustJwtGrantIssuerBody"> (optional)</param>
        /// <returns>ClientTrustedJwtGrantIssuer</returns>
        public ClientTrustedJwtGrantIssuer TrustJwtGrantIssuer(ClientTrustJwtGrantIssuerBody clientTrustJwtGrantIssuerBody = default(ClientTrustJwtGrantIssuerBody))
        {
            Ory.Client.Client.ApiResponse<ClientTrustedJwtGrantIssuer> localVarResponse = TrustJwtGrantIssuerWithHttpInfo(clientTrustJwtGrantIssuerBody);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Trust an OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to establish a trust relationship for a JWT issuer to perform JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523).
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientTrustJwtGrantIssuerBody"> (optional)</param>
        /// <returns>ApiResponse of ClientTrustedJwtGrantIssuer</returns>
        public Ory.Client.Client.ApiResponse<ClientTrustedJwtGrantIssuer> TrustJwtGrantIssuerWithHttpInfo(ClientTrustJwtGrantIssuerBody clientTrustJwtGrantIssuerBody = default(ClientTrustJwtGrantIssuerBody))
        {
            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = clientTrustJwtGrantIssuerBody;


            // make the HTTP request
            var localVarResponse = this.Client.Post<ClientTrustedJwtGrantIssuer>("/trust/grants/jwt-bearer/issuers", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("TrustJwtGrantIssuer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Trust an OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to establish a trust relationship for a JWT issuer to perform JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523).
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientTrustJwtGrantIssuerBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientTrustedJwtGrantIssuer</returns>
        public async System.Threading.Tasks.Task<ClientTrustedJwtGrantIssuer> TrustJwtGrantIssuerAsync(ClientTrustJwtGrantIssuerBody clientTrustJwtGrantIssuerBody = default(ClientTrustJwtGrantIssuerBody), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientTrustedJwtGrantIssuer> localVarResponse = await TrustJwtGrantIssuerWithHttpInfoAsync(clientTrustJwtGrantIssuerBody, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Trust an OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to establish a trust relationship for a JWT issuer to perform JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523).
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientTrustJwtGrantIssuerBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientTrustedJwtGrantIssuer)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientTrustedJwtGrantIssuer>> TrustJwtGrantIssuerWithHttpInfoAsync(ClientTrustJwtGrantIssuerBody clientTrustJwtGrantIssuerBody = default(ClientTrustJwtGrantIssuerBody), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = clientTrustJwtGrantIssuerBody;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ClientTrustedJwtGrantIssuer>("/trust/grants/jwt-bearer/issuers", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("TrustJwtGrantIssuer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update a JSON Web Key Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <param name="clientJSONWebKey"> (optional)</param>
        /// <returns>ClientJSONWebKey</returns>
        public ClientJSONWebKey UpdateJsonWebKey(string kid, string set, ClientJSONWebKey clientJSONWebKey = default(ClientJSONWebKey))
        {
            Ory.Client.Client.ApiResponse<ClientJSONWebKey> localVarResponse = UpdateJsonWebKeyWithHttpInfo(kid, set, clientJSONWebKey);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update a JSON Web Key Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <param name="clientJSONWebKey"> (optional)</param>
        /// <returns>ApiResponse of ClientJSONWebKey</returns>
        public Ory.Client.Client.ApiResponse<ClientJSONWebKey> UpdateJsonWebKeyWithHttpInfo(string kid, string set, ClientJSONWebKey clientJSONWebKey = default(ClientJSONWebKey))
        {
            // verify the required parameter 'kid' is set
            if (kid == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'kid' when calling AdminApi->UpdateJsonWebKey");
            }

            // verify the required parameter 'set' is set
            if (set == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'set' when calling AdminApi->UpdateJsonWebKey");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("kid", Ory.Client.Client.ClientUtils.ParameterToString(kid)); // path parameter
            localVarRequestOptions.PathParameters.Add("set", Ory.Client.Client.ClientUtils.ParameterToString(set)); // path parameter
            localVarRequestOptions.Data = clientJSONWebKey;


            // make the HTTP request
            var localVarResponse = this.Client.Put<ClientJSONWebKey>("/keys/{set}/{kid}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateJsonWebKey", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update a JSON Web Key Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <param name="clientJSONWebKey"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientJSONWebKey</returns>
        public async System.Threading.Tasks.Task<ClientJSONWebKey> UpdateJsonWebKeyAsync(string kid, string set, ClientJSONWebKey clientJSONWebKey = default(ClientJSONWebKey), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientJSONWebKey> localVarResponse = await UpdateJsonWebKeyWithHttpInfoAsync(kid, set, clientJSONWebKey, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update a JSON Web Key Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="kid">The kid of the desired key</param>
        /// <param name="set">The set</param>
        /// <param name="clientJSONWebKey"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientJSONWebKey)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientJSONWebKey>> UpdateJsonWebKeyWithHttpInfoAsync(string kid, string set, ClientJSONWebKey clientJSONWebKey = default(ClientJSONWebKey), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'kid' is set
            if (kid == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'kid' when calling AdminApi->UpdateJsonWebKey");
            }

            // verify the required parameter 'set' is set
            if (set == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'set' when calling AdminApi->UpdateJsonWebKey");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("kid", Ory.Client.Client.ClientUtils.ParameterToString(kid)); // path parameter
            localVarRequestOptions.PathParameters.Add("set", Ory.Client.Client.ClientUtils.ParameterToString(set)); // path parameter
            localVarRequestOptions.Data = clientJSONWebKey;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<ClientJSONWebKey>("/keys/{set}/{kid}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateJsonWebKey", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update a JSON Web Key Set Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="clientJSONWebKeySet"> (optional)</param>
        /// <returns>ClientJSONWebKeySet</returns>
        public ClientJSONWebKeySet UpdateJsonWebKeySet(string set, ClientJSONWebKeySet clientJSONWebKeySet = default(ClientJSONWebKeySet))
        {
            Ory.Client.Client.ApiResponse<ClientJSONWebKeySet> localVarResponse = UpdateJsonWebKeySetWithHttpInfo(set, clientJSONWebKeySet);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update a JSON Web Key Set Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="clientJSONWebKeySet"> (optional)</param>
        /// <returns>ApiResponse of ClientJSONWebKeySet</returns>
        public Ory.Client.Client.ApiResponse<ClientJSONWebKeySet> UpdateJsonWebKeySetWithHttpInfo(string set, ClientJSONWebKeySet clientJSONWebKeySet = default(ClientJSONWebKeySet))
        {
            // verify the required parameter 'set' is set
            if (set == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'set' when calling AdminApi->UpdateJsonWebKeySet");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("set", Ory.Client.Client.ClientUtils.ParameterToString(set)); // path parameter
            localVarRequestOptions.Data = clientJSONWebKeySet;


            // make the HTTP request
            var localVarResponse = this.Client.Put<ClientJSONWebKeySet>("/keys/{set}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateJsonWebKeySet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update a JSON Web Key Set Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="clientJSONWebKeySet"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientJSONWebKeySet</returns>
        public async System.Threading.Tasks.Task<ClientJSONWebKeySet> UpdateJsonWebKeySetAsync(string set, ClientJSONWebKeySet clientJSONWebKeySet = default(ClientJSONWebKeySet), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientJSONWebKeySet> localVarResponse = await UpdateJsonWebKeySetWithHttpInfoAsync(set, clientJSONWebKeySet, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update a JSON Web Key Set Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="set">The set</param>
        /// <param name="clientJSONWebKeySet"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientJSONWebKeySet)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientJSONWebKeySet>> UpdateJsonWebKeySetWithHttpInfoAsync(string set, ClientJSONWebKeySet clientJSONWebKeySet = default(ClientJSONWebKeySet), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'set' is set
            if (set == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'set' when calling AdminApi->UpdateJsonWebKeySet");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("set", Ory.Client.Client.ClientUtils.ParameterToString(set)); // path parameter
            localVarRequestOptions.Data = clientJSONWebKeySet;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<ClientJSONWebKeySet>("/keys/{set}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateJsonWebKeySet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update an OAuth 2.0 Client Update an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="clientOAuth2Client"></param>
        /// <returns>ClientOAuth2Client</returns>
        public ClientOAuth2Client UpdateOAuth2Client(string id, ClientOAuth2Client clientOAuth2Client)
        {
            Ory.Client.Client.ApiResponse<ClientOAuth2Client> localVarResponse = UpdateOAuth2ClientWithHttpInfo(id, clientOAuth2Client);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update an OAuth 2.0 Client Update an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="clientOAuth2Client"></param>
        /// <returns>ApiResponse of ClientOAuth2Client</returns>
        public Ory.Client.Client.ApiResponse<ClientOAuth2Client> UpdateOAuth2ClientWithHttpInfo(string id, ClientOAuth2Client clientOAuth2Client)
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'id' when calling AdminApi->UpdateOAuth2Client");
            }

            // verify the required parameter 'clientOAuth2Client' is set
            if (clientOAuth2Client == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'clientOAuth2Client' when calling AdminApi->UpdateOAuth2Client");
            }

            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Ory.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = clientOAuth2Client;


            // make the HTTP request
            var localVarResponse = this.Client.Put<ClientOAuth2Client>("/clients/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateOAuth2Client", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update an OAuth 2.0 Client Update an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="clientOAuth2Client"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ClientOAuth2Client</returns>
        public async System.Threading.Tasks.Task<ClientOAuth2Client> UpdateOAuth2ClientAsync(string id, ClientOAuth2Client clientOAuth2Client, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Client.Client.ApiResponse<ClientOAuth2Client> localVarResponse = await UpdateOAuth2ClientWithHttpInfoAsync(id, clientOAuth2Client, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update an OAuth 2.0 Client Update an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
        /// </summary>
        /// <exception cref="Ory.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the OAuth 2.0 Client.</param>
        /// <param name="clientOAuth2Client"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ClientOAuth2Client)</returns>
        public async System.Threading.Tasks.Task<Ory.Client.Client.ApiResponse<ClientOAuth2Client>> UpdateOAuth2ClientWithHttpInfoAsync(string id, ClientOAuth2Client clientOAuth2Client, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'id' when calling AdminApi->UpdateOAuth2Client");
            }

            // verify the required parameter 'clientOAuth2Client' is set
            if (clientOAuth2Client == null)
            {
                throw new Ory.Client.Client.ApiException(400, "Missing required parameter 'clientOAuth2Client' when calling AdminApi->UpdateOAuth2Client");
            }


            Ory.Client.Client.RequestOptions localVarRequestOptions = new Ory.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Ory.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Ory.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = clientOAuth2Client;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<ClientOAuth2Client>("/clients/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateOAuth2Client", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
